#  Хитрости SSH
Ssh (secure shell) – это программа, позволяющая получить защищенный доступ к удаленным системам. Большинству из вас она должна быть хорошо знакома, однако не все знают, что ssh обладает рядом дополнительных мощных возможностей, таких как вход без запроса пароля, автоматическое выполнение комманд в удаленной системе и даже монтирование удаленных папок. Часть из них уже упоминалось в ранее выходивших статьях на эту тему, кое-что описывается на страницах нашего журнала впервые.

Для начала напомним самые базовые вещи, которые должны быть и так хорошо знакомы большинству IT-шников. Ну так, на всякой случай :) ssh работает по принципу клиент-сервер. Это значит, что на сервере, к которому мы хотим подключиться, должен быть запущен демон ssh. В современных дистрибутивах Linux сервер ssh, как правило, установлен по умолчанию. Сервер запускается командой типа /etc/init.d/ssh start. По умолчанию он ожидает соединений на порту 22, так что если вы используете файрвол, убедитесь, что этот порт открыт. После установки и запуска ssh- сервера мы можем удаленно подключиться к нему. Чтобы войти пользователем user1 на сервер remote_server (который указывается через доменное имя или IP-адрес) нужно воспользоваться следующей простой командой:

    ssh user1@remote_server

После ввода пароля для доступа к удаленной машине появится измененное приглашение для ввода команд, которое выглядит следующим образом:

    user1@remote_server:~$

Это означает, что мы успешно произвели вход и сейчас работаем в окружении удаленного сервера. Теперь каждая команда будет выполняться на удаленном сервере, с привилегиями того пользователя, под которым мы вошли (в данном случае user1).

## SCP – защищенное копирование файлов

SCP является составной частью пакета OpenSSH. Эта команда позволяет копировать файлы или папки с удаленного сервера (или на него), используя для этого протокол ssh. Благодаря использованию ssh, SCP является отличной заменой для небезопасного протокола FTP, которой широко используется в Интернете.

Простейший пример использования SCP выглядит так:

    scp file.txt user1@remote_server:~/

При этом локальный файл file.txt будет скопирован на удаленный сервер и помещен в домашний каталог пользователя user1. Вместо ~/ можно использовать другой путь, например /tmp, /home/public или любую другую папку, в которой пользователь user1 имеет права на запись.
Чтобы скопировать файл с удаленного сервера на локальный компьютер, используется другой синтаксис SCP:

    scp user1@remote_server:~/file.txt .

При этом файл file.txt, расположенный в домашнем каталоге пользователя user1 в удаленной системе, будет скопирован в локальную папку (в которой мы сейчас находимся).

Стоит обратить внимание на следующие параметры SCP:

-r – рекурсивное копирование папок (включая подкаталоги);  
-P port – использовать нестандартный порт (по умолчанию 22) – этот параметр следует использовать, если сервер ожидает соединения на нестандартном порту. Этот параметр может быть полезен при соединении из сети, защищенной файрволлом. Запуск SSH-сервера на порту 443 (используемом для защищенных HTTP-соединений) - это лучший способ обойти ограничения, установленные сетевым администратором.

## Графические интерфейсы для SCP

Если вам не нравится работать с консолью, то вы можете использовать графический (или псевдографический) клиент SCP. Midnight Commander – одна из программ, обладающая функциями SCP-клиента (Меню > Правая панель/Левая панель > Shell-соединение). Nautilus и Konqueror также поддерживают SCP. Для подключения к удаленной системе в адресной строке надо ввести ssh://user1@remote_server:~/. При этом файлы могут копироваться, как если бы они были расположены локально. В среде MS Windows есть отличное приложение WinSCP. Его интерфейс очень похож на Total Commander. Кстати, существует плагин для Total Commander, позволяющий выполнять SCP-подключения.

## ssh без паролей – генерация ключей

Необходимость ввода пароля при каждом ssh-соединении может сильно раздражать. С другой стороны, незащищенное удаленное соединение - это огромный риск с точки зрения безопасности. Решением этой проблемы является авторизация с помощью пары из открытого (public) и секретного (private) ключей.

Пара ключей обычно генерируется с помощью команды ssh-keygen. Ниже показан результат выполнения такой команды. Возможно использование ключей RSA, DSA или ed25519
```bash
$ ssh-keygen -t rsa
Generating public/private rsa key pair.
Enter file in which to save the key
(/home/user1/.ssh/id_rsa):
Enter passphrase (empty for no passphrase):
Enter same passphrase again:
Your identification has been saved in
/home/user1/.ssh/id_rsa.
Your public key has been saved in
/home/user1/.ssh/id_rsa.pub.
The key fingerprint is:
xx:xx:xx:xx:xx:xx:xx:xx:xx:xx:xx:xx:xx:xx:xx:xx
```
Когда программа просит указать пароль для ключа, нужно просто нажать ENTER. При этом будет создан ключ без пароля. Имейте в виду, что это представляет угрозу безопасности, так как это понижает безопасность удаленной системы до уровня безопасности вашей локальной системы (злоумышленник, получивший доступ к секретному ключу, хранящемуся в вашей локальной системе, может воспользоваться им для доступа к удаленной системе - прим. пер.). Поэтому делайте это на свой страх и риск. Когда ssh-keygen закончит свою работу, вы увидите, что были сгенерированы два ключа. Секретный ключ находится в /home/user1/.ssh/id_rsa. Его нельзя делать общедоступным ни при каких обстоятельствах. Второй ключ (открытый) находится в /home/user1/.ssh/id_rsa.pub, к нему можно предоставить публичный доступ.

Теперь, если мы хотим получить доступ к удаленной системе с нашего локального компьютера без запроса пароля (используя только эти два ключа), мы должны добавить информацию о нашем открытом ключе в файл authorized_keys, расположенный в папке ~/.ssh в удаленной системе. Для этого можно воспользоваться следующими командами:

$ scp /home/user1/.ssh/id_rsa.pub user1@remote_server:~/
$ ssh user1@remote_server
$ cat ~/id_rsa.pub >> ~/.ssh/authorized_keys

Обратите внимание, что третья команда выполняется на удаленном сервере. После этой процедуры все действия, выполняемые на удаленном сервере через ssh, не будут требовать ввода пароля. Это позволит существенно упростить нашу работу с удаленным сервером.

Обратите внимание, что если вам нужен беспарольный доступ с удаленного сервера на локальный, аналогичная процедура должна быть проведена с удаленного сервера. Авторизация с использованием ключей - это односторонний процесс. Секретный ключ может авторизовать публичный, но не наоборот.

выполнение команд в удаленной системе

Теперь, когда мы можем войти в удаленную системы без пароля, почему бы не выполнить несколько удаленных команд? В некоторых случаях это может быть полезно, например, когда нам нужно выполнять некоторую команду ежедневно. Раньше мы не могли автоматизировать этот процесс, так как требовался ручной ввод пароля (или указание его в виде простого текста, что является небезопасным).

Один из интересных способов применения беспарольного входа - это «удаленное оповещение». Допустим, что на удаленном сервере работает очень важный процесс, например веб-сервер Apache. Мы хотим получить уведомление, когда система начинает испытывать нехватку ресурсов (жесткий диск переполнен или нагрузка на систему слишком высока). В этом случае мы можем отправить уведомление по электронной почте. Но помимо этого, мы можем выполнить удаленную команду, которая воспроизведет звуковой сигнал в нашей локальной системе. Для этого можно воспользоваться, например, такой командой:

ssh user1@local_server 'play /usr/share/sounds/gaim/arrive.wav'

Эта команда, выполненная скриптом на удаленном сервере, произведет беспарольный вход пользователем user1 на local_server (на котором мы обычно работаем) и воспроизведет файл с помощью команды play (которая обычна доступна в Linux).

X forwarding - удаленный запуск графических приложений

Одной из наименее известных функций ssh является перенаправление протокола X. Это позволяет запускать практически любое X приложение удаленно! Для этого всего лишь нужно добавить параметр -X при соединении с удаленным сервером:

ssh -X user1@remote_server

После этого изображения всех запущенных X-приложений будут перенаправлены на ваш локальный X-сервер. В файле /etc/ssh/ssh_config можно включить постоянное использование перенаправления X11 (указав ForwardX11 yes). Разумеется, чтобы этот параметр сработал, удаленный ssh-сервер должен также поддерживать перенаправление X11. Настроить это можно, отредактровав файл /etc/ssh/sshd_config. Однако в большинстве дистрибутивов Linux необходимые настройки уже выполнены по умолчанию.

Следующий пример показывает запуск одиночной команды с X перенаправлением:

ssh -X user1@remote_server 'psi'

При этом на удаленном сервере будет запущена программа PSI, а ее изображение будет направлено на локальный экран.

Разумеется, скорость приложений, выполняемых удаленно, будет зависеть в первую очередь от скорости сетевого соединения. В локальной сети они будут работать практически без задержек (даже такие вещи, как Totem, воспроизводящий фильм DivX). В случае интернет-соединения, DSL-линии будет достаточно, чтобы приложения типа Skype или Thunderbird работали без особых проблем.

sshfs - монтирование удаленной папки

Работать с файлами, расположенными на удаленном сервере, через ssh может быть неудобно, особенно если приходится часто копировать различные файлы в обоих направлениях. Использование протокола fish:// в Midnight Commander или Konqueror является частичным решением, но fish работает медленнее, чем ssh, и часто тормозит при копировании файлов. Идеальным решением было бы смонтировать удаленный ресурс и работать с ним через ssh. И такая возможность есть благодаря sshfs и проекту fuse.

Fuse - это модуль ядра (недавно он был принят в официальную ветку 2.6), позволяющий непривилегированным пользователям монтировать различные файловые системы. Sshfs - это программа, созданная самим автором fuse, которая позволяет монтировать удаленные папки или файловые системы, используя ssh. Суть проста - удаленная папка монтируются в папку локальной файловой системы. После этого все операции над этой папкой производятся, как если бы это была обычная локальная папка, с той только разницей, что файлы перемещаются через ssh в фоновом режиме. После установки программы остается только добавить пользователя, которому мы хотим предоставить право на монтирование файловых систем через ssh, в группу fuse (используя команду

# usermod -G -a fuse user1

или

# adduser user1 fuse

или вручную отредактировав файл /etc/group. Также необходимо, чтобы был загружен модуль fuse:

# modprobe fuse

После этого, мы можем смонтировать удаленную папку с помощью sshfs:

sshfs user1@remote_server:/tmp ~/remote_folder

Указанная выше команда смонтирует папку /tmp, расположенную на удаленном сервере, в папку ~/remote_folder на локальной машине. Копирование любых файлов в эту папку будет производиться по сети с использованием SCP. Редактирование, создание и удаление файлов будет производиться таким же образом.

По окончании работы с удаленной системой мы можем отмонтировать ее:

fusermount -u ~/remote_folder

Если мы постоянно работаем с этой папкой, то можно добавить ее в таблицу /etc/fstab. При этом она будет автоматически монтироваться при загрузки системы, либо можно будет монтировать ее вручную (при использовании параметра noauto) без необходимости каждый раз указывать адрес удаленной папки. Пример записи в /etc/fstab:

sshfs#user1@remote_server:/tmp /home/user1/remote_folder/ fuse defaults,auto 0 0

Если мы планируем использовать fuse и sshfs регулярно, то нужно добавить fuse в файл /etc/modules. Иначе придется каждый раз загружать модуль fuse вручную.

заключение

Как видите, ssh - это мощный инструмент для удаленного доступа. Если вам приходится часто работать с удаленными UNIX-системами, то вам стоит освоить его функции и использовать их на практике. Умение работать с ssh помогает сделать ежедневную работу более эффективной и приятной.



Borys Musielak, впервые опубликовано на PolishLinux.org.

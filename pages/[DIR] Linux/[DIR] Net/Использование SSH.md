# Использование SSH
## Introduction
**SSH** (Secure SHell) это программа терминала, использующая шифрование, которая заменяет классическую программу telnet на Unix и подобных ей операционных системах.

Кроме программы удаленного терминального доступа, `ssh` предоставляет и другие инструменты, такие как `scp`(secure copy), `sftp`(secure file transfer protocol), `sshfs`(secure filesistem).

Предполагается, что свободная версия `ssh`-`OpenSSH` уже установлена. В противном случае обратитесь к документации по своему дистрибутиву и установите.

## Способы аутентификации
SSH предоставляет 3 способа аутентификации клиента: по ip адресу клиента (небезопасно), по публичному ключу клиента и стандартный парольный метод. Вот как работает ssh версии 2: при запросе клиента сервер сообщает ему, какие методы аутентификации он поддерживает (это определяется в опции PreferredAuthentications sshd.conf) и клиент по очереди пытается проверить их. По умолчанию клиент вначале пытается аутентифицироваться своим адресом, затем публичным ключом и, если ничего не сработало, передает пароль, введенный с клавиатуры (при этом пароль шифруется асимметрическим шифрованием). После прохождения аутентификации одним из методов из имеющихся у клиента и сервера пар ключей генерируется ключ симметрического шифрования, который, как я описывал во введении, генерируется на основании своего секретного и удаленного публичного ключей. После чего все последующие данные, передаваемые через ssh, шифруются данным ключом (обычно используется алгоритм aes с длиной ключа 128 бит). Отмечу, что протокол ssh версии 1 имел некоторые баги в шифрации передаваемого трафика и являлся по сути методом безопасной аутентификации, поэтому по современным меркам данный протокол считается небезопасным. Протокол версии 2 поддерживает более современные методы шифрования тарфика, также вместе с данными посылаются контрольные суммы формата sha или md5, что исключает подмену или иную модификацию передаваемого трафика (чего не было у ssh версии 1).

###1. По адресу клиента.
При данном способе аутентификации происходит следующее: каждый клиент и сервер имеют свои пары ключей RSA, которые называются ключи хоста. При этом существует несколько методов проверки адреса клиента. Сервер смотрит файлы `$HOME/.rhosts`, `$HOME/.shosts`, `/etc/hosts.equiv` или `/etc/ssh/shosts.equiv`, если же сервер настроен на проверку ключей клиентов (а это нужно в соображениях безопасности, т.к. иначе злоумышленник может подменить ip клиента на свой), то он дополнительно проверяет `/etc/ssh/ssh_known_hosts` и `$HOME/.ssh/known_hosts`. Естественно, что файлы, расположенные в домашних каталогах сервера, действуют на пользователя, в чьем каталоге они размещены, а файлы, расположенные в /etc имеют глобальный эффект. Для начала расскажу о синтаксисе вышеперечисленных файлов:

- .rhosts — определяет адрес машины и имя пользователя, с которой данному пользователю открыт доступ (файл расположен в домашнем каталоге пользователя).
- .shosts — аналогичен .rhosts, но предназначен исключительно для ssh, поэтому использовать лучше именно данный файл. 
Пример .shhosts:
  user1.test.ru user1
  userstend.test.ru user1
  null.test.ru user1
- /etc/hosts.equiv — также содержит пары имя машины/имя пользователя, но имеет эффект на всех пользователей.
- /etc/shosts.equiv — аналог hosts.equiv, но применяется только ssh, что также более предпочтительно.

  Пример файла /etc/shhosts.equiv:

        `+` user1.test.ru user1
        `-` server.test.ru xakep

  Знак `+` означает разрешение пользователю работать с сервером с данного адреса, знак `-` запрещает подобное действие.

- `/etc/ssh/ssh_known_hosts` и `$HOME/.ssh/known_hosts` — данные файлы содержат список адресов и соответствующих им публичных ключей. При запросе клиента сервер генерирует рандомную строку и шифрует ее публичным ключом удаленного хоста. Клиент, получив данную строку, расшифровывает ее своим секретным ключом (который имеется только у него) и зашифровывает полученную строку ключом сервера. Сервер получает зашифрованное сообщение, расшифровывает своим секретным ключом и сравнивает с исходной. Если строки совпали, то клиент имеет валидный секретный ключ, что дает ему право захода на данный сервер. Но для начала клиент должен иметь правильный адрес, которому соответствует публичный ключ на сервере в файле `ssh_known_hosts`. Файл состоит из 3-х полей: адрес (или адреса, разделенные запятой), публичный ключ для него одной (!) строкой и дополнительное поле комментариев(необязательно).

  Пример файла `known_hosts`:

        user1.test.ru {SOME_VERY_LONG_PUBLIC_KEY}

  Адрес клиента должен быть в полном формате(name.domain), иначе могут быть проблемы. Кроме этого, в адресе можно использовать шаблоны * и ?. Публичные ключи вставляются в данный файл самим администратором из генерированных клиентом ssh(identity.pub) публичных ключей. Вообще создание `ssh_known_hosts` — это прерогатива администратора (aka root).

И еще добавлю: при аутентификации по хосту лучше использовать ssh_known_hosts, т.к. этот метод достаточно безопасен, если публичные ключи клиентов были получены из доверенного источника. Другие методы аутентификации не исключают подмену адреса, и потому считаются небезопасными.

###2. Аутентификация пользователя по его публичному ключу.

Аутентификация удаленного пользователя по ключу идентична проверке ключа хоста (с посылкой рандомной строки) за тем исключением, что проверяется не адрес клиентской машины, а ключ клиента и имя пользователя. Данному пользователю на сервере может соответствовать его публичный ключ, тогда клиент, имея секретный ключ сможет заходить на сервер без пароля. Механизм работы я только что описал, поэтому сразу же расскажу, каким образом аутентифицировать пользователей по ключу (предполагается, что используется клиент и сервер openssh):

Для генерации пары ключей используйте программу `ssh-keygen`. Для указания типа ключа укажите `ssh-keygen -t {RSA DSA}`, например, `ssh-keygen -t rsa` создаст пару ключей RSA длиной 1024 бита. Для указания файла, в котором следует сохранить ключи, можно использовать опцию `-f` (традиционно используются файлы `$HOME/.ssh/id_rsa` и `$HOME/.ssh/id_dsa` для ключей rsa и dsa соответственно), для указания длины ключа в битах используйте опцию `-b`:
```
ssh-keygen -t rsa -b 2048 -f $HOME/.ssh/id_rsa
```
В результате работы программа запросит ввод пароля для шифрования секретного ключа, чтобы исключить использование его при попадании к посторонним лицам, не знающим пароля (пароль желательно выбирать не короче 10-и символов). После этого вам будет необходимо вводить данный пароль каждый раз при использовании секретного ключа (далее я расскажу, как избежать этого при помощи программы `ssh-agent`). После работы `ssh-keygen` создается пара ключей: один секретный (зашифрованный введенным паролем), а другой публичный с расширением `.pub` `(id_rsa.pub)`. Публичный ключ вам необходимо будет скопировать в домашнюю директорию сервера `$HOME/.ssh/authorized_keys`. После этого сервер будет знать ключ данного пользователя и сможет аутентифицировать вас без пароля. Файл `authorized_keys` может содержать несколько публичных ключей, допустимых для данного пользователя: просто поместите их в данный файл по порядку. После этих операций вы сможете входить, имея секретный ключ, на сервер, где размещен ваш публичный ключ, причем под тем пользователем, в чьем домашнем каталоге данный ключ находится. Пароля удаленного пользователя не требуется, необходимо только знать пароль расшифровки секретного ключа. Для переноса своего публичного ключа на сервер надо использовать только безопасные источники, иначе ваш ключ могут подменить. Для переноса публичного ключа клиента служит программа `ssh-copy-id`. Для начала необходимо сделать следующее:

`# ssh-copy-id -i public_key_file user@machine`

После соединения с севером machine и передачей имени пользователя user (необходимо указывать, если удаленное имя отличается от локального) происходит парольная аутентификация заданного пользователя(или текущего) на удаленной машине, затем происходит копирование ключа `public_key_file` (или `$HOME/.ssh/identity.pub`, если имя файла не указано) на сервер в `$HOME/.ssh/authorized_keys`. После этого можно входить на сервер, не используя пароль пользователя. При выполнении данной операции учтите, что вы должны скопировать на удаленную машину ПУБЛИЧНЫЙ ключ, иначе все будет очень печально (думаю, ясно почему).

###3. Обычная парольная аутентификация.

Тут можно отметить только одно: в любом случае вначале идет обмен асимметрическими ключами, и хеш пароля передается в зашифрованном виде. Парольная аутентификация используется наиболее часто, но, честно говоря, ssh предлагает более удобные методы аутентификации, и пользоваться ими IMHO можно, если к ssh есть все заплатки. И, конечно же, протокол версии 1 необходимо вырубить вообще. Итак, начинаем настройку…

###  Fingerprinf - Проверка отпечатка
При первом подключении, _ssh_ проверит, если хост с данным отпечатком неизвестен, будет запрошено подтверждение _yes/no_, если ответ будет _yes_, хост будет добавлен в файл _~/.ssh/known_hosts_ и при следующих подключениях будет сразу запрошен пароль для подключения, если ответ будет _no_, соединение будет разорвано.
```bash
# ssh test_host
The authenticity of host 'test_host (192.168.16.54)' can't be established.
DSA key fingerprint is 14:4a:aa:d9:73:25:46:6d:0a:48:35:c7:f4:16:d4:ee.
Are you sure you want to continue connecting (yes/no)? yes
```
Получить отпечаток можно командой _ssh-keygen -l_ на сервере:
```bash
# ssh-keygen -l -f /etc/ssh/ssh_host_rsa_key.pub      # Для RSA ключа
2048 61:33:be:9b:ae:6c:36:31:fd:83:98:b7:99:2d:9f:cd /etc/ssh/ssh_host_rsa_key.pub
# ssh-keygen -l -f /etc/ssh/ssh_host_dsa_key.pub      # Для DSA ключа (по-умолчанию)
2048 14:4a:aa:d9:73:25:46:6d:0a:48:35:c7:f4:16:d4:ee /etc/ssh/ssh_host_dsa_key.pub
```
## Настройка
Большинство администраторов просто оставляет конфиги клиента и сервера по умолчанию, чтобы руки не марать. Но это неправильно: в разных системах эти конфиги различаются очень существенно, и это приводит к неразберихе и непониманию работы сервера, что создает дополнительную угрозу безопасности (свой сервак — потемки). Для этого я решил описать файлы конфигурации `ssh` на примерах `ssh_config` и `sshd.conf` для клиента и сервера соответственно. Для конфигурации клиента используется файл `$HOME/.ssh/config` или `/etc/ssh/ssh_config` (для всей системы). Файл имеет следующий формат: определение адреса хоста и параметры для него. В адресе можно использовать обычные шаблоны * и ?, все имена параметров и их значения должны быть набраны в том же регистре, что и в примере (иначе параметр воспринят не будет). Вот пример `ssh_config`, который содержит наиболее полезные опции (на самом деле описывать некоторые параметры конфигурации ssh не имеет смысла, т.к. употребляются они очень редко):
```bash
# Определение хоста, в данном случае включает все хосты домена test.ru, можно
# использовать одиночный символ * чтобы указать параметры доступа к любому хосту
Host *.test.ru
# Эта опция определяет, будет ли ssh использовать передачу данных от удаленного
# X сервера через свой безопасный канал. Далее будет описано, каким образом
# организуются безопасные туннели через ssh. Данная возможность позволяет
# защищать по идее небезопасные протоколы(X, pop, smtp, ftp) шифрованием ssh. По
# умолчанию данная опция no
ForwardX11 no
# Список предпочтительных методов аутентификации через ssh версии 2. Первым
# стоит самый предпочтительный протокол, думаю, значения данного параметра ясны
PreferredAuthentications hostbased,publickey,keyboard-interactive
# Этот параметр определяет, будет ли производится стандартная парольная проверка
# По умолчанию yes
PasswordAuthentication yes
# Число попыток ввода пароля перед тем, как клиент отсоединяется от сервера. По
# умолчанию пароль можно вводить трижды
NumberOfPasswordPrompts 3
# Использование ssh(2 версия) аутентификации через rhosts и RSA ключи. По
# умолчанию no.
HostbasedAuthentication yes
# Будет ли клиент пытаться работать по rsh, если ssh недоступен или по каким-то
# причинам работает неправильно. По умолчанию no
FallBackToRsh no
# Используем ли rsh. По умолчанию no
UseRsh no
# Режим скрипта, когда не спрашиваются пароли с терминала. По умолчанию no
BatchMode no
# Дополнительно проверяется ключ хоста удаленной машины в
# known_hosts, что исключает подмену ip. По умолчанию yes.
CheckHostIP yes
# Данный параметр означает, будет ли клиент доверять полученным от серверов
# ключам. Параметр может принимать следующие значения: yes - ключи никогда
# автоматически не помещаются в known_hosts, ask - ключ может быть помещен в
# known_hosts только после подтверждения пользователя, no - все ключи
# автоматически размещаются в known_hosts(небезопасно). По умолчанию ask.
StrictHostKeyChecking ask
# Следующие параметры определяют секретные ключи ssh различных форматов:
# rsa и dsa
IdentityFile $HOME/.ssh/id_rsa
IdentityFile $HOME/.ssh/id_dsa
# Порт, на удаленной машине используемый ssh. По умолчанию 22
Port 22
# Версии протоколов, используемые клиентом в порядке убывания приоритета.
Protocol 2
# Протокол шифрования для версии 1 протокола ssh
Cipher 3des
# Возможные протоколы шифрования в порядке убывания приоритета для протокола
# версии 2
Ciphers aes128-cbc,3des-cbc,blowfish-cbc,cast128-cbc,arcfour,aes192-cbc,aes256-cbc
# Значение escape-символа, сигнализирующего, что идущие за ним символы
# необходимо воспринимать специальным образом(например ~. вызовет немедленное
# отключение клиента от сервера) при передаче двоичных данных необходимо
# установить этот параметр в none, что выключает escape последовательности. По
# умолчанию ~
EscapeChar ~
# Управление работой компрессии зашифрованнного трафика. Полезный параметр для
# медленных сетей, т.к. зашифрованные данные обычно увеличиваются в размере за
# счет фиксированной длины ключа. Компрессия позволяет уменьшить количество
# данных, передаваемых через сеть, но увеличит время работы самого протокола.
# Так что включать этот параметр желательно на медленных соединениях. По
# умолчанию no.
Compression yes
# Управляет посылкой сообщений о доступности клиента серверу, что позволяет
# нормально разорвать соединение, если произошла неполадка в сети или иная,
# приведшая к разрыва соединения. Если связь плохая, то лучше эту опцию
# отключить, чтобы дисконнект не происходил после каждой ошибки сети. По
# умолчанию yes.
KeepAlive yes
```
Я думаю, что в данном примере все объяснено достаточно подробно и скажу только вот что: в большинстве случаев опции по умолчанию работают неплохо, необходимо только отключить поддержку `ssh` версии 1 и настроить необходимые методы аутентификации (кроме парольной) и указать пути доступа к ключам. На этом закончим с настройкой клиента и настроим сервер. Файл конфигурации сервера sshd находится в `/etc/ssh/sshd_config`, и многие его параметры совпадают с аналогичными в `ssh_config`, но здесь нет определений хостов, как это было в `ssh_config`. Я все же приведу пример `sshd_config`, чтобы далее не возникало вопросов:
```bash
# Номер порта и версия протокола
Port 22
Protocol 2

# Адреса, на которых слушает сервер, можно также указывать
# порт (server.test.ru:2022), но назначение ssh нестандартного порта
# нецелесообразно, т.к. заинтересует потенциальных взломщиков("А чего это там
# они прячут?")
ListenAddress 192.168.1.1

# Список допустимых пользователей для данного сервера. Можно применять два
# формата: список пользователей, разделенных пробелом, и список пользователей и
# хостов, разделенных пробелом(USER@HOST - разрешает данному пользователю доступ
# только с данного адреса). Можно использовать выражения * и ?. Подобное же
# назначение имеют опции AllowGroups, DenyUsers и DenyGroups(для групп нельзя
# указывать адрес клиента)
AllowUsers *@*.test.ru
DenyUsers xakep lamer
DenyGroups x*
# Создайте группу, членам которой разрешен доступ
AllowGroup ssh

# Ключ сервера для протокола версии 1
HostKey /etc/ssh/ssh_host_key
# Ключи rsa и dsa для ssh версии 2
HostKey /etc/ssh/ssh_host_rsa_key
HostKey /etc/ssh/ssh_host_dsa_key

# Данные значения определяют длину ключа сервера и его время жизни для
# использования ssh версии 1(данный ключ будет заново генерироваться через
# заданное время)
#KeyRegenerationInterval 3600
#ServerKeyBits 768

# Далее определяем методы аутентификации для данного сервера и ее параметры

# Сервер отсоединяется по происшествии данного времени в секундах, если клиент
# не проходит аутентификацию
LoginGraceTime 600
# Разрешаем заходить по ssh руту. Долгое время эта тема обсуждалась на форуме,
# но я думаю все же, что со внутренней сети рут может заходить и по ssh (для
# этого надо настроить должным образом iptables). Также можно запретить руту
# входить по паролю: without-password, разрешая вход только по публичному ключу
PermitRootLogin yes
# Проверка sshd прав доступа и владельцев домашних каталогов. Полезно для тех
# пользователей, что дают права всему 0777. Хотя таких болванов лучше держать на
# расстоянии от сервера(лучше всего это делать бревном, подвешенным в серверной
# к потолку, чтобы придать нежеланному гостю должное ускорение, и не забудьте
# оббить конец бревна какой-нибудь железкой, иначе бревна придется менять
# слишком часто ;)
StrictModes yes

# Аутентификация через RSA (версия 1)
RSAAuthentication yes
# Аутентификация пользователя по ключу (версия 2)
PubkeyAuthentication yes
# Определяет публичный ключ пользователя для аутентификации по ключу. Можно
# применять шаблоны: %u - имя пользователя, %h - домашний каталог пользователя.
AuthorizedKeysFile .ssh/authorized_keys

# Не используем аутентификацию rhosts
RhostsAuthentication no
# Можно также игнорировать rhosts и shosts при hostbased autentification,
# используя только known_hosts файл.
#IgnoreRhosts yes
# Используем ли аутентификацию через known_hosts совместно с .rhosts или
# .shosts. Опция действительна только для протокола версии 1.
RhostsRSAAuthentication no
# То же самое, что и предыдущее только для версии 2
HostbasedAuthentication no
# Если нет доверия к known_hosts, то их можно не использовать при hostbased
# autentification. По умолчанию no
IgnoreUserKnownHosts no

# Чтобы запретить посылку хешей паролей через туннель ssh задайте значение
# данной опции no. По умолчанию аутентификация по паролю разрешена
PasswordAuthentication yes
# Можно также разрешить пустые пароли, но это полный отстой, т.к. это огромная
# дыра на сервере, через которую можно наделать много гадостей! Поэтому должно
# быть no (по умолчанию)
PermitEmptyPasswords no

# Выключаем по умолчанию включённый механизм авторизации пользователя по системной базе.
ChallengeResponseAuthentication no

# Аутентификация через механизм PAM.
UsePAM yes

# Если не используется, лучше отключить
# AllowTcpForwarding no

# Передача протокола иксов через туннель ssh
#X11Forwarding no
# Используем в качестве x-сервера данный, т.е. клиент, запуская у себя x-клиента
# будет фактически использовать наш сервер, но все данные от сервера к клиенту
# будут шифроваться, что есть хорошо!
# X11UseLocalhost yes
# При логине пользователя выводим /etc/motd: в некоторых системах это отменено в
# целях безопасности
# PrintMotd no
# Сообщаем пользователю время и место последнего логина, ситуация, аналогичная
# предыдущей
# PrintLastLog no
# Посылать клиенту сообщения о доступности
KeepAlive yes
# Включён по умолчанию sandbox-режим "UsePrivilegeSeparation=sandbox",
# использующий rlimit, systrace, seсcomp filter и другие подсистемы для более
# жесткой изоляции кода, работающего на стадии до начала аутентификации
# (pre-auth). Sandbox-режим позволяет воспрепятствовать выполнению системных
# вызовов к ядру и использованию сокетов, в дополнение к ранее практикуемым
# сбросу прав до непривилегированного пользователя и помещением процесса в
# chroot-окружение /var/empty. Таким образом, в случае проникновения через
# уязвимость в OpenSSH при использовании новой защиты злоумышленник не сможет
# эксплуатировать локальную уязвимость в ядре для повышения прав или провести
# атаку на другие хосты (создать сокет, запустить прокси и т.п.). Для Linux при
# возможности используется seсcomp filter, но если в ядре нет поддержки данной
# технологии применяется изоляция на основе rlimit
UsePrivilegeSeparation sandbox
# Максимальное число возможных соединений, где не произошло аутентификации. Если
# клиентов, не прошедших аутентификацию больше, то новые соединения не будут
# обрабатываться
MaxStartups 10:30:100
# Путь к файлу, который будет отображаться при входе клиента ДО аутентификации
Banner /etc/ssh_message
# Проверка соответствия ip адреса клиента и его символического имени в backzone,
# затем снова сравнение имени с ip адресом. Таким образом (извращенным)
# проверяется подлинность ip, но метод этот достаточно тормозной и по умолчанию
# он отключен
VerifyReverseMapping no

# Новые системы, работающие через ssh. В данном примере определяется
# "безопасный" ftp сервер - sftp, аналогичный доступ пользователя, но с
# возможностью передачи файлов(т.е. пользователь получает доступ ко всем своим
# файлам и нет возможности настройки разрешений и виртуальных пользователей,
# как, например в proftpd). По сути дела подсистемы ssh могут обеспечивать
# прохождение других протоколов по сети, но под "крылышком" ssh. Например, для
# sftp сервера есть одноименный sftp клиент. Его интерфейс полностью идентичен
# оригинальному ftp, но с одним отличием: происходит та же самая аутентификация
# пользователя на удаленном сервере(методами ssh), но вместо оболочки с
# пользователем взаимодействует подсистема, в данном случае sftp.
Subsystem sftp /usr/lib/ssh/sftp-server 
```
Не каждому узлу вашей сети (или внешнему) необходим доступ к вашей системе. Большинство хостов, очевидно, не должны иметь доступ к вашей системе. OpenSSH позволяет администраторам определить хосты, которым разрешен доступ (или запрещен) в `/etc/hosts.allow и` `/etc/hosts.deny . Рекомендуется запретить доступ с любого хоста, а затем предоставить доступ для выбранных узлов (или подсетей).
```bash
### /etc/hosts.allow
sshd: 192.168.1.0/24


### /etc/hosts.deny
sshd: ALL
```
Теперь можно запустить (перезапустить) сервис `sshd` (см. документацию дистрибутива).

## Создание и использование ключей
Начиная с OpenSSH 6.5:

"ssh и sshd теперь отклоняют RSA-ключи от старых проприетарных клиентов и серверов, использующих устаревшую схему формирования сигнатур RSA+MD5 и методы обмена ключей на основе уязвимых способов расчёта хэшей. Соединение с такими системами пока допускается, но только с использованием ключей DSA. В будущем поддержка будет прекращена полностью; "

* rsa не рекомендуется для шифрования, хотя и является более универсальным, но его стойкость ниже чем у dsa. Поэтому лучше выбирать dsa.
* генерировать ключи без пароля это очень плохо, т.к. имея лишь публичный ключ, можно получить приватный.

Создаем ключ:

`User$ ssh-keygen -t dsa`

При генерации ключа вводим парольную фразу.

Копируем ключ на удаленную машину:

`User$ ssh-copy-id -i $HOME/.ssh/id_dsa remote_host`

### Смена пароля ключа
Хотя беспарольные ключи и имеют свою область применения (например, использование в скриптах), обычно надо защищать ключ паролем. Делается это так:
```
$ ssh-keygen -p -f .ssh/id_dsa Enter old passphrase: Key has comment '.ssh/id_dsa'
Enter new passphrase (empty for no passphrase):
Enter same passphrase again:
Your identification has been saved with the new passphrase.
```

### Установка ключей на сервер
#### С помощью ssh-copy-id
Самый простой способ выложить свой ключ на сервер для дальнейшего
применения – воспользоваться скриптом `ssh-copy-id` из стандартной поставки OpenSSH. В самом простом случае (если ключ у вас один и загружен с помощию ssh-agent)

командная строка будет выглядеть так:

`ssh-copy-id user@host`

После чего скрипт спросит у вас пароль к серверу и сам выложит ключ
туда, куда надо. В более сложных случаях придётся либо прочесть `man
ssh-copy-id` или же выложить ключ вручную.

#### Вручную
Ключ представляет из себя простую текстовую строку – можно копировать
его через буфер, отправлять по email и пр.

Скопируем его по scp:

`scp .ssh/id_dsa.pub user@remotehost:~/.ssh/`

Подробнее о scp – далее.

`ssh user@remotehost`

Далее на remotehost:

`cd .ssh/ cat id_dsa.pub >> authorized_keys rm id_dsa.pub`

Добавили публичную часть ключа к списку разрешённых.

Всё, можно проверять (со своей машины):

`ssh user@remotehost`

Теперь никаких паролей спрашивать не должно для всех сервисов на
базе ssh (scp/sftp).

Если всё-таки спрашивает:

1. Проверить в sshd_config параметры:  
   `Protocol (только 2) RSAAuthentication yes PubkeyAuthentication yes`
2. запустить клиента с ключом -v (Verbose mode)
3. запустить на сервере ещё одного демона на другом порту с ключом -d

### Пароли
Это всё отлично, но что делать с приватным ключом?

Если на него не устанавливать ключевую фразу – то злоумышленник может 
забрать файлик с приватным ключом и ходить от вашего имени. Если
ключевую фразу установить – то при каждом соединении надо вводить
эту ключевую фразу, опять нехорошо...

Помнить один пароль вместо десятка – конечно, легче.

Чтобы не расшифровывать ключ (вводя пароль) при каждом соединении,
можно использовать программу ssh-agent.

#### ssh-agent
Программа ssh-agent обычно запускается вначале вашей X-сессии, или из сценария запуска оболочки, например ~/.bash_profile . Она работает путем создания доменного сокета Unix и регистрации подходящих переменных среды, так чтобы все последующие приложения могли воспользоваться ее сервисами, подсоединяясь к этому сокету. Очевидно, имеет смысл запускать ее только в родительском процессе Вашей X-сессии, если Вы хотите использовать набор расшифрованных закрытых ключей во всех последующих X-приложениях.

`user $ eval ssh-agent`

Этот ssh-agent будет хранить ключи расшифрованными, пока Вы его не завершите. Если Вы хотите установить время существования ключей, используйте параметр -t, как описано в man ssh-agent .

При запуске, ssh-agent должен сообщить Вам PID запущенного ssh-agent, и также установить несколько переменных среды, а именно SSH_AUTH_SOCK и SSH_AGENT_PID . Он также должен автоматически добавить ~/.ssh/id_dsa к своему набору и запросить соответствующую парольную фразу. Если Вы имеете другие закрытые ключи, Вы можете пожелать добавить их к запущенному ssh-agent, для этого Вы можете использовать команду ssh-add:

`user $ ssh-add keyfile`

А теперь начинается магия. Так как у Вас уже есть расшифрованный закрытый ключ, Вы можете получить доступ к серверу по ssh без ввода какого-либо пароля:

`user $ ssh server`

Если ssh-add при запуске не имеет терминала для ввода паролей (в
случае, например, запуска из того же .xsession), но установлена
переменная окружения 'DISPLAY', то он попытается воспользоваться
программой ssh-askpass.

Как закрыть ssh-agent, в случае если вам это потребуется.

`user $ ssh-agent -k`

Вы можете завершить его работу, как и в случае с любым другим процессом, запустив команду killall ssh-agent .

####  keychain
Keychain управляет приватными ключами. При запуске он спросит вашу секретную фразу для ключа (каждого) и сохранит ее. Таким образом, ваш приватный ключ защищен паролем, но вам не придется вводить ваш пароль раз за разом.

Установите пакет keychain.

Отредактируйте ваш ~/.bashrc или ~/.zshrc и добавьте следующие строки:

```bash
eval `/usr/bin/keychain id_dsa`
[ -z "$HOSTNAME" ] && HOSTNAME=`uname -n`
[ -f $HOME/.keychain/$HOSTNAME-sh ] && . $HOME/.keychain/$HOSTNAME-sh
#[ -f $HOME/.keychain/$HOSTNAME-sh-gpg ] && . $HOME/.keychain/$HOSTNAME-sh-gpg # для GPG-ключей
```

Для использования в скриптах:

```bash
# Load keychain variables and check for id_dsa
[ -z "$HOSTNAME" ] && HOSTNAME=`uname -n`
. $HOME/.keychain/$HOSTNAME-sh 2>/dev/null
ssh-add -l 2>/dev/null | grep -q id_dsa || exit 1
```
Запустите man keychain и узнаете, как это сделать для других оболочек.

Закройте шелл и откройте снова. Keychain должен запуститься, и, если это его первый запуск, спросит секретную фразу для указанного приватного ключа.

#### Соображения безопасности
Конечно же, использование ssh-agent ухудшает безопасность Вашей системы. Если бы другой пользователь использовал Ваш терминал пока Вы были в ванной, он смог бы войти на все ваши серверы без пароля. В результате, это является риском для серверов, к которым вы подсоединяетесь. Если Вы этим пользуетесь, будьте уверены в том, что Вы приняли необходимые меры длы обеспечения безопасности Ваших сессий.

#### Устранение проблем
Большинство из описанного должно работать без проблем, но если Вы с ними столкнулись, Вы определенно захотите знать несколько полезных вещей.

- Если вы не можете соединиться без ssh-agent, рассмотрите использование ssh с аргументами -vvv, чтобы узнать что произошло. Иногда, сервер не настроен для использования аутентификации с открытым ключом, иногда он настроен на запрашивание локальных паролей в любом случае! Если это как раз тот самый случай, Вы могли бы использовать с ssh параметр -o, или изменить файл конфигурации sshd_config на сервере.
- Если у Вас проблемы с ssh-agent или keychain, это может быть потому что Вы не используете оболочку, которая понимает используемые ими команды. Проконсультируйтесь с man-страницами для программ ssh-agent и keychain для поиска подробностей по работе с другими оболочками.
- Вы также можете посетить [keychain homepage](https://github.com/funtoo/keychain) для поиска других советов по использованию.

## X Forwarding
Если при заходе по ssh использовать опцию -X, то ssh выставит
правильный $DISPLAY и проделает всё, что надо с xhost/xauth.

Все сервера, которым вы доверяете, можно перечислить в /.ssh/config
(на той машине, откуда вы будете заходить):

`Host hostname1 host2.domain.com ForwardX11 yes`

## Тунелизация
Если Вам нужна тунелизация через ssh, включите `AllowTcpForwarding yes` в `/etc/ssh/sshd_config`

SSH имеет встроенную возможность передавать данные с локального порта на удаленный, используя сетевой туннель, причем данные, передаваемые через данный туннель будут шифроваться. То есть происходит аутентификация на удаленной системе, а затем начинается перенаправление трафика через туннель. Таким образом, можно перенаправлять любой трафик, а протокол иксов может работать в интерактивном режиме, для этого необходимо включить соответствующие опции в файлах конфигурации сервера и клиента. Для других же портов необходимо вызывать ssh с параметром `-L{LOCAL_PORT}:{LOCAL_ADDRESS}:{REMOTE_PORT}`:

`# ssh -L10101:localhost:101 server.test.ru`

Такой туннель довольно быстро умирает, т.к. сервер автоматически убивает «ленивых» клиентов. Поэтому можно применить метод, который позволяет устанавливать произвольное время удержания туннеля: выполнить sleep на удаленном сервере:

`# ssh -f -L10101:loclahost:101 server.test.ru sleep 100`

Данная команда держит туннель 100 секунд, чего достаточно для любого соединения. И еще одна вещь: когда по туннелю передаются данные, то он не уничтожается, что хорошо для реализации безопасного ftp-, smtp- и pop3-протоколов (впрочем, sftp-сервер имеется уже и в поставке openssh, применение его не должно вызвать затруднений sftp [user@]hostname, т.к. фактически это особая реализация ssh протокола и механизм работы sftp абсолютно идентичен механизму ssh). Чтобы отключить перенаправление портов, необходимо установить опцию sshd AllowTcpForwarding в no. Использование длительной задержки ssh-туннеля несколько уменьшает безопасность, т.к. во время ожидания злоумышленник имеет больше шансов на атаку (но механизм ssh версии 2 позволяет избежать подобной ситуации подписыванием передаваемых сообщений).

> Статья взята с сайта http://www.linuxcenter.ru/. [Оригинал](http://www.linuxcenter.ru/lib/articles/soft/ssh.phtml).

###  Создание защищенного SSH туннеля
_SSH туннелирование_ позволяет делать форвардинг портов (перенаправление) через _SSH туннель_, обеспечивая прохождение трафика через заблокированые порты (работает только с протоколом _TCP_).

_SSH Туннель_ создается из слушающего сокета на определенном порту _localhost_. Затем все принятые на локальном хосте/порту соединения перенаправляются через _SSH_ на удаленный хост/порт.
```bash
# ssh -L localport:desthost:destport user@gate  # Хост назначения будет представлять из себя локальный порт
# ssh -R destport:desthost:localport user@gate  # Локальный порт будет перенаправлен на указанный порт удаленного хоста
# ssh -X user@gate   # Принудительный форвардинг Х сеанса
```
Кстати, можно указывать эти ключи не только при запуске ssh. Вы можете поднять туннель для уже установленного ssh-соединения, нажав `C` и отдав команду `-R port:host:hostport` с появившейся консоли.

#### Пример использования
Предположим, вам нужно из внешней сети зайти на сервер терминалов
(ts.acme.localnet) во внутренней сети acme.com. Установить с ним
соединение напрямую не получается – на шлюзе gate.acme.com запрещены
соединения на порт 3389 (порт Windows Terminal Services по умолчанию).
Но если у вас есть возможность зайти по ssh на gate.acme.com (или на
любую другую машину во внутренней сети) – то вы можете воспользоваться
этим, чтобы подключиться-таки к ts.acme.localnet:

`ssh -L 1234:ts.acme.localnet:3389 gate.acme.com`

Пока это соединение активно, вы это можете подключаться к
localhost:1234 и попадать при этом на ts.acme.localnet:

`rdesktop localhost:1234`

####  Прямой форвардинг на шлюз
Предположим, нам нужно получить доступ к _CVS (порт 2401)_ и _http (порт 80)_, запущенных на удаленном хосте. Ниже вы видите простой пример реализации, мы подключаем к локальному порту _2401_, соответствующий порт удаленного хоста, а для доступа к удаленному порту _80_ используем локальный порт _8080_. Единожды открыв _ssh_ сессию, все соответствующие сервисы удаленного хоста, будут доступны на локальных портах.

`# ssh -L 2401:localhost:2401 -L 8080:localhost:80 user@gate`

####  Форвардинг портов Netbios и удаленного рабочего стола
Имеем _Windows SMB_ сервер за шлюзом, и отсутствие _ssh_. Необходимо получить доступ к расшаренным _SMB_папкам и удаленному рабочему столу.

`# ssh -L 139:smbserver:139 -L 3388:smbserver:3389 user@gate`

Теперь _SMB_ шара доступна по адресу _\\127.0.0.1\_, но только если отключена локальные шара, поскольку локальная шара тоже использует _139_ порт.

Что-бы иметь возможность оставить локальные расшаренные русурсы включенными, нужно создать новый виртуальный интерфейс с новым _IP_ адресом для создания туннеля, _SMB_ шара будет подключена через этот _IP_ адрес. Кроме того, локальный _RDP_ уже использует порт 3389, поэтому мы выбираем _3388_. Для приведенного ниже примера, будем использовать виртуальный _IP_ адрес _10.0.0.1_.

- With putty use Source port=10.1.1.1:139. It is possible to create multiple loop devices and tunnel. On Windows 2000, only putty worked for me. On Windows Vista also forward the port 445 in addition to the port 139. Also on Vista the patch KB942624 prevents the port 445 to be forwarded, so I had to uninstall this path in Vista.
- With the ssh.com client, disable "Allow local connections only". Since ssh.com will bind to all addresses, only a single share can be connected.

Теперь создаем _loopback_ интерфейс с IP адресом _10.1.1.1_:

- # System->Control Panel->Add Hardware # Добавляем новое устройство.
- # Устанавливаем устройство выбрав его вручную Network adapters -> Microsoft -> Microsoft Loopback Adapter.
- Настраиваем IP адрес созданного устройства на 10.1.1.1 маска 255.255.255.0, без шлюза.
- advanced-> WINS, Enable LMHosts Lookup; Disable NetBIOS over TCP/IP.
- # Enable Client for Microsoft Networks. # Отключить общие файлы и принтеры для сетей Microsoft.

Перезагружаемся. Теперь можно подключиться к расшаренным ресурсам по адресу _\\10.1.1.1_ и к удаленному рабочему столу по адресу _10.1.1.1:3388_.

####  Отладка
Если что-то не работает:

- Порты проброшены правильно, netstat -an? ищите 0.0.0.0:139 или 10.1.1.1:139
- Попробуйте подключиться через telnet по адресу 10.1.1.1 139
- Должна быть включена опция "Local ports accept connections from other hosts".
- Сервис "File and Printer Sharing for Microsoft Networks" отключен на loopback интерфейсе?

###  Подключение двух клиентов, сидящих за NAT
Есть две машины, находящиеся за _NAT_ шлюзом, клиенту _cliadmin_ нужно подключится к клиенту _cliuser_, оба имеют доступ к Linux-шлюзу по _ssh_. Поскольку будут использованы порты, выше _1024_, _root_ доступ не понадобится.

На шлюзе мы используем порт _2022_.

На клиенте _cliuser_:

`# ssh -R 2022:localhost:22 user@gate            # Форвардинг порта клиента 22, на порт 2022, шлюза`

На клиенте cliadmin:

`# ssh -L 3022:localhost:2022 admin@gate         # Форвардинг порта клиента 3022, на порт 2022 шлюза`

Теперь администратор может напрямую подключится к _cliuser_:

`# ssh -p 3022 admin@localhost                   # local:3022 -> gate:2022 -> client:22`

####  Подключение к рабочему столу, расположенному за NAT
Предположим нужно получить доступ к Windows клиенту с _VNC_ слушающем на _5900_ порту.

От клмента _cliwin_ на шлюз:

`# ssh -R 15900:localhost:5900 user@gate`

От клиента cliadmin:

`# ssh -L 5900:localhost:15900 admin@gate`

Теперь админ может напрямую подключится к клиентскому VNC:

`# vncconnect -display :0 localhost`

###  Отладка multi-hop ssh tunnel
Предположим, вы не можете получить прямой доступ к _ssh_, только через промежуточные хосты(например из-за проблем с маршрутизацией), но получить соединение клиент-сервер вам необходимо, к примеру что-бы скопировать файлы через _SCP_ или пробросить порт для _SMB_. Сделать это можно, организовав туннель из цепочки хостов.

Допустим нам нужно перебросить _ssh_ порт клиента к серверу, в два скачка. Когда туннель будет создан, будет возможно прямое подключение клиент - сервер.

Создание туннеля в одной оболочке:

клиент -> хост1 -> хост2 -> сервер and dig tunnel 5678
```
Клиент># ssh -L5678:localhost:5678 host1        # 5678 произвольный порт для туннеля
хост_1># ssh -L5678:localhost:5678 host2        # звено 5678 с хохта1 на хост2
хост_2># ssh -L5678:localhost:22 server         # и тцннель на порт 22 сервера
```

####  Использование туннеля через другой шелл
клиент -> сервер использующий туннель 5678
```
Клиент># ssh -L5678:localhost:5678 host1        # 5678 произвольный порт для туннеля
хост_1># ssh -L5678:localhost:5678 host2        # звено 5678 с хохта1 на хост2
хост_2># ssh -L5678:localhost:22 server         # и тцннель на порт 22 сервера
```
## Ввод-вывод по сети
SSH перенаправляет потоки ввода-вывода. При грамотном использовании это позволяет сэкономить очень много времени!

Несколько примеров с небольшими пояснениями:

`ssh server ls -l > file.txt`

ls -l выполняется на server, а file.txt создаётся на клиенте.

`tar cz dir | ssh server 'tar xz'`

`tar cz` пишет архив в stdout, который по сети в шифрованном виде передаётся на server и там `tar xz` его разворачивает.

`mkisofs -r -J directory | ssh remotehost \ 'sudo cdrecord dev=0,0,0 speed=16 driveropts=burnfree -'`

`mkisofs` создаёт iso-образ на нашей стороне, образ передаётся по сети на `remotehost` и там записывается с помощью `cdrecord`

`ssh user@remotehost \ 'sudo dd if=/dev/cdrom' > image.iso`

Созданный image.iso – копия диска в /dev/cdrom на машине remotehost

## Windows-клиенты
###  Использование Windows клиента с ssh.com
Коммерческую версию клиента, можно скачать с официального сайта: [ssh.com](ssh.com). Ключи сгенерированные с помощью _ssh.com_ клиента нужно конвертировать в формат OpenSSH сервера, это делается с помощью _ssh-keygen_.

- Создать пару ключей с помощью ssh.com клиента: _Settings - User Authentication - Generate New...._
- Тип ключа _DSA_; Длина ключа _2048_.
- Скопировать публичный ключ на сервер в папку _~/.ssh_.
- Ключи находятся в _C:\Documents and Settings\%USERNAME%\Application Data\SSH\UserKeys_.
- Используя _ssh-keygen_ на сервере, конвертируем ключи:

```
# cd ~/.ssh
# ssh-keygen -i -f keyfilename.pub >> authorized_keys2
```
Использовать можно как _DSA_, так и _RSA_ алгоритм. Имейте в виду, сгенерированные нами ключи не защищены паролем, а это определенный минус для безопасности.

###  Использование putty для Windows
Putty, отличный бесплатный клиент под Windows.

- Создать пару ключей с помощью утилиты _puttygen_ (идет в комплекте с полным дистрибутивом)
- Сохранить публичный и приватный ключи, например в _C:\Documents and Settings\%USERNAME%\.ssh_.
- Копировать публичный ключ на сервер в папку _~/.ssh_:

`# scp .ssh/puttykey.pub root@192.168.51.254:.ssh/`

Используя _ssh-keygen_ на сервере, конвертировать ключи в формат _OpenSSH_:

```bash
# cd ~/.ssh
# ssh-keygen -i -f puttykey.pub >> authorized_keys2
```
В PuTTy: _Connection - SSH - Auth_, прописать путь к приватному ключу.

### Putty-sg
### XShell

##  scp - Безопасное копирование
Пара простых команд:
```bash
# scp file.txt remote_host:/tmp
# scp joe@remote_host:/www/*.html /www/tmp
# scp -r joe@remote_host:/www /www/tmp
```
Еще пара примеров использования _SCP_

`# scp -P 2525 ./file_to_copy root@remote_host:/tmp/copied_file`

В данном случае, у нас удаленный сервер SSH, сидит на нестандартном порту, поэтому с помощью опции _-P_, указываем на какой порт подключаемся. Не путайте с ключем _-p_ у программы _ssh_, для указания порта, для _scp_, опция _-p_, означает _"Сохранить время модификации, время последнего доступа, и режимы, оригинального файла"_. В случае, если у пользователя, под которым вы пытаетесь подключится для копирования, установлен пароль ( что собственно и должно быть ), SCP попросит его ввести, выглядит это примерно так.
```bash
# scp -P 2222 ./file_to_copy user@remote_host:~/copied_file
# Password:                                                     вводим пароль, жмем Ентер
# copied_file
```
Для рекурсивного копирования каталогов используйте ключ '-r'.

Символические ссылки при копировании разыменовываются.

## sftp
## sshfs
Подключить удаленную папку можно с помощью _Konqueror_ или _Midnight Commander_, введя путь в виде _user@gate_. Кроме того можно воспользоваться утилитой _sshfs_, это клиент для файловых систем на базе _SCP_. See _fuse sshfs_.


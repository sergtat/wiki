# Полезные Unix утилиты. Pipe Viewer
Pipe viewer — это консольная утилита мониторинга за данными проходящими через конвейер команд. Она может быть вставлена в любой обычный конвейер между двумя процессами и позволяет получить визуальные ориентиры о том как быстро данные передаются через данный конвейер, как долго это происходит, когда примерно он должен завершиться и помогает оценить когда в целом процесс будет выполнен. 

## Как использовать PV?

Давайте начнем с нескольких простых примеров и продолжим более сложными.

Предположим, что у Вас есть файл “access.log” в несколько гигабайт, который содержит логи Вашего веб сервера. Вы хотите сжать его, ну, скажем в (.gz) архив. Обычно это делается так:

    $ gzip -c access.log > access.log.gz

Так как файл достаточно большой (несколько гигабайт), у Вас нет ориентира насколько долгим будет процесс сжатия. Закончится ли он скоро? Или через 30 минут?

Используя pv Вы можете точно оценить время, которое займет данный процесс. Посмотрим на ту-же самую команду исполненную через pv:

    $ pv access.log | gzip > access.log.gz
    611MB 0:00:11 [58.3MB/s] [=> ] 15% ETA 0:00:59

Pipe viewer действует как “cat”, за исключением того, что добавляет индикатор процесса. Мы можем видеть, что gzip обработал 611МБ данных за 11 секунд. Это занимает 15% от всех данных и до завершения всего процесса остается около 59 секунд.

Вы можете вставлять различные pv процессы в различных местах. Для примера, Вы можете замерить насколько быстро данные читаются с диска и сколько данных выдет gzip:

    $ pv -cN source access.log | gzip | pv -cN gzip > access.log.gz
    source: 760MB 0:00:15 [37.4MB/s] [=> ] 19% ETA 0:01:02
    gzip: 34.5MB 0:00:15 [1.74MB/s] [ <=>  ]

Здесь мы определили параметр “-N” для создания имени потока (имена: source и gzip). Параметр “-c” предотвращает «замусорвание» вывода одного из pv процессов другим.

Этот пример показывает, что файл “access.log” читается на скорости 37.4МБ/с, а gzip записывает данные только на скорости 1.74МБ/с. Имея такие данные мы можем посчитать коэффициент сжатия. Он равен 37.4/1.74 = 21x!

Заметим, что процесс gzip не показывает сколько данных осталось или как быстро они закончатся. Это происходит потому, что процесс pv, идущий после gzip, не знает сколько данных выдаст gzip (это простой вывод сжатых данных из входного потока). Однако, первый pv процесс, знает точно сколько данных осталось, потому-что он непосредственно занимается их чтением.

Другой аналогичный пример будет паковать целую директорию с файлами в единый tar архив:

    $ tar -czf — . | pv > out.tgz
    117MB 0:00:55 [2.7MB/s] [> ]

В этом примере pv показывает скорость вывода команды “tar -czf”. Не очень интересно и это не предоставляет информации о том, как много данных осталось. Нам необходимо выдать общий размер сжимаемых данных данных, для pv, это делается таким путем:

    $ tar -cf — . | pv -s $(du -sb . | awk ‘{print $1}’) | gzip > out.tgz
    253MB 0:00:05 [46.7MB/s] [> ] 1% ETA 0:04:49

Что здесь происходит: мы говорим tar создать “-c” архив всех файлов текущей директории “.” (рекурсивно) и вывести данные в стандартный вывод “-f -”. Далее, мы указываем размер “-s” всех файлов текущей директории для pv. Команда “du -sb . | awk ‘{print $1}’” возвращает число байт в текущей директории, и скармливает это число для pv через параметр “-s”. Затем мы сжимаем gzip все содержимое и выводим результат в файл out.tgz. Таким образом, “pv” знает, сколько данных осталось обработать и она показывает нам, что это займет еще 4 минуты 49 секунд.

Другой замечательный пример — копирование большого количества данных через сеть с использованием утилиты “nc”, о которой я расскажу в следующий раз.

Предположим, у Вас есть два компьютера A и B. Вы хотите очень быстро перенести директорию с A на B. Наибыстрейший путь — использовать tar и nc, и время операции с pv.

    # on computer A, with IP address 192.168.1.100
    $ tar -cf — /path/to/dir | pv | nc -l -p 6666 -q 5
    # on computer B
    $ nc 192.168.1.100 6666 | pv | tar -xf —

Все файлы из /path/to/dir на компьютере A будут перенесены на компьютер B, и у Вас будет возможность посмотреть как быстро это делается.

Если Вы хотите получить индикатор процесса, Вы добавляете “pv -s $(…)” трюк из предыдущего примера (только на компьютере A).

Другой забавный пример от читателя блога alexandru. Он показывает как посчитать насколько быстро компьютер читает из /dev/zero:

    $ pv /dev/zero > /dev/null
    157GB 0:00:38 [4,17GB/s]

Я надеюсь Вам понравились мои примеры и Вы научились чему-то новому. Я люблю объяснять то, что я сам изучаю! :) 

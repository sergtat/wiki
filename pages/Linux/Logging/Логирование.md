#  Логирование
Для перехвата предупреждений и ошибок, которые могут свидетельствовать о происходящей атаке или успешном взломе, следует подключать дополнительное журналирование. Часто злоумышленники сканируют систему и проверяют ее на зуб перед атакой.

Также немаловажно, чтобы файлы журналов были легко читаемыми и обозримыми.
##  Выбор демона
Выбирать будем из:
1. sysklogd -  Реализует два демона системного журнала. Syslogd демон расширенная версия стандартной программы утилиты Беркли. Он отвечает за протоколирование сообщений, полученных от программ и сервисов локального узла, а также с удаленных хостов. Этот демон слушает источники сообщений ядра и отвечает за расстановку приоритетов и обработку сообщений операционной системы. Она может использоваться как клиент Syslogd либо как отдельная программа. Klogd может быть использована для декодирования EIP адресов, если он может найти System.map файл. Syslogd является самым распространенным средством журналирования для Linux и Unix. Он способен делать ротацию журналов, однако использование /usr/sbin/logrotate с вызовом по расписанию (logrotate настраивается с помощью файла /etc/logrotate.conf) может оказаться полезней, так как у logrotate есть много дополнительных возможностей. Частота ротации подбирается в зависимости от загрузки системы.
1. syslog-ng - Замена syslog. Это многофункциональный демон протоколирования системных сообщений. По сравнению со стандартным демоном syslogd он имеет ряд отличий:  
    * усовершенствованная схема конфигурации
    * фильтрация сообщений не только по приоритетам, но и по их содержанию
    * поддержка regexps (regular expressions)
    * более гибкое манипулирование и организация логов
    * возможность шифрования канала передачи данных с помощью IPSec/Stunnel   
1. rsyslog - усовершенствованный демон обработки журнальных сообщений syslogd. Среди прочего, rsyslog представляет возможность ведения системного журнала через TCP, SSL, TLS и RELP, запись в базы данных (MySQL, PostgreSQL, Oracle и другие), уведомление по электронной почте, полностью конфигурируемый формат сообщений. Rsyslog с легкостью заменяет стандартный syslogd и понимает синтаксис его конфигурационных файлов.
1. socklog - A small and secure replacement for syslogd. Очень мало документации.
1. metalog - Служба журналирования с очень гибкими возможностями настройки. Очень мало документации. Не может отправлять журнал на удаленный сервер, но дает преимущество, когда речь о скорости и гибкости журналирования. Он может вести журналы по названию программы, срочности, подсистеме (как и syslogd), и комплектуется разборщиком регулярных выражений, с помощью которых можно запускать внешние сценарии при обнаружении заданных шаблонов. При необходимости это может оказаться очень полезным.
1. syslogread - простой и легкий демон. Сеть только UDP. Мало информации.

##  Syslog-ng
Syslog-ng, за некоторыми отличиями, обладает теми же возможностями, что и syslog и metalog. Он может фильтровать сообщения по уровню и содержимому (как metalog), вести удаленное журналирование, как syslog, обрабатывать журналы, получаемые от syslogd (даже потоки от Solaris), записывать в TTY, запускать программы, и служить сервером журналирования. То есть, он сочетает лучшие черты обоих средств журналирования с возможностью расширенной настройки.

Ниже приведен слегка подправленный классический конфигурационный файл.

```
options {
    chain_hostnames(off);
    stats_freq(43200);
    owner(root);
    group(root);
    perm(0640);
    dir_perm(0740);
    create_dirs(yes);
    use_fqdn(no);
    keep_hostname(yes);
    use_dns(no);
    flush_lines(0);
};

#источник, откуда читать журнал
#source where to read log
source src { unix-stream("/dev/log"); internal(); };
# kernel messages
source kernsrc { file("/proc/kmsg"); };
# from a chrooted bind install
# source namedsrc { unix-stream("/var/named/chroot/dev/log"); };

#получатели
destination authlog { file("/var/log/auth.log"); };
destination cron { file("/var/log/cron.log"); };
destination daemon { file("/var/log/daemon.log"); };
destination kern { file("/var/log/kern.log"); };
destination lpr { file("/var/log/lpr.log"); };
destination user { file("/var/log/user.log"); };
destination mail { file("/var/log/mail.log"); };
destination mailinfo { file("/var/log/mail.info"); };
destination mailwarn { file("/var/log/mail.warn"); };
destination mailerr { file("/var/log/mail.err"); };
destination newscrit { file("/var/log/news/news.crit"); };
destination newserr { file("/var/log/news/news.err"); };
destination newsnotice { file("/var/log/news/news.notice"); };
destination debug { file("/var/log/debug"); };
destination messages { file("/var/log/messages"); };
destination shorewall { file("/var/log/shorewall/firewall.log"); };
destination blacklist { file("/var/log/shorewall/blacklist.log"); };
destination noblklst { file("/var/log/shorewall/noblacklist.log"); };
destination miniserv { file("/var/log/webmin/miniserv.error"); };               # Webmin miniserv.error
destination console { usertty("root"); };
destination console_all { file("/dev/tty12"); };
destination xconsole { pipe("/dev/xconsole"); };

#создание фильтров
filter f_auth { facility(auth); };
filter f_authpriv { facility(auth, authpriv); };
filter f_cron { facility(cron); };
filter f_daemon { facility(daemon); };
filter f_kern { facility(kern); };
filter f_mail { facility(mail); };
filter f_user { facility(user); };
filter f_debug { not facility(auth, authpriv, news, mail); };
filter f_messages { level(info..warn) and not facility(auth, authpriv, mail, news); };
filter f_emergency { level(emerg); };
filter f_info { level(info); };
filter f_notice { level(notice); };
filter f_warn { level(warn); };
filter f_crit { level(crit); };
filter f_err { level(err); };
######################################################
# This part seems to be wrong, see the discussion
# on discussion tab
# EDIT: this part should be:
# filter f_failed { match("failed" value(MESSAGE)); };                          # Filter everything except "failed" keyword
# OR
# filter f_failed { message("failed"); };
#
filter f_failed { match("regex" value("failed")); };
filter f_denied { match("regex" value("denied")); };
filter f_shorewall { not match("regex" value("Shorewall")); };                  # Filter everything except regex keyword Shorewall
filter f_noshorewall { match("regex" value("Shorewall")); };                    # Filter regex keyword Shorewall
filter f_blacklist { not match("regex" value("blacklst")); };                   # Filter everything except regex keyword blacklst
filter f_noblklst { match("regex" value("blacklst")); };                        # Filter regex keyword blacklst
filter f_miniserv { not match("regex" value("webmin")); };
######################################################

#связывание фильтров с получателями
log { source(src); filter(f_authpriv); destination(authlog); };
log { source(src); filter(f_cron); destination(cron); };
log { source(src); filter(f_daemon); destination(daemon); };
log { source(kernsrc); filter(f_kern); destination(kern); };
log { source(src); filter(f_mail); destination(mail); };
log { source(src); filter(f_user); destination(user); };
log { source(src); filter(f_mail); filter(f_info); destination(mailinfo); };
log { source(src); filter(f_mail); filter(f_warn); destination(mailwarn); };
log { source(src); filter(f_mail); filter(f_err); destination(mailerr); };
log { source(kernsrc); filter(f_shorewall); destination(shorewall); };                          # Shorewall full log
log { source(kernsrc); filter(f_blacklist); destination(blacklist); };                          # Shorewall blacklist log
log { source(kernsrc); filter(f_noblklst); destination(noblklst); };                            # Shorewall clean (no blacklist) log
log { source(src); filter(f_miniserv); filter(f_noshorewall); destination(miniserv); };         # Webmin error log

#журнал по умолчанию
log { source(src); destination(console_all); };
log { source(src); destination(xconsole); };
```

Syslog-ng очень легко настраивается, но с той же легкостью можно что-либо упустить в файле настройки, так как он очень велик. Автор также обещает дополнительные возможности, например, шифрование, опознание, сжатие и обязательную проверку прав доступа (MAC mandatory access control). С такими возможностями программа станет незаменимой для журналирования в сети, так как злоумышленник не сможет перехватывать журнал.

К тому же у syslog-ng есть еще одно достоинство: он не требует прав администратора для запуска!

##  Ротация логов
###  С помощью logrotate
Утилита logrotate служит для контролирования системы логирования (записи отчетов о работе и ошибках программ).
Logrotate отлично конфигурируемая утилита: можно задать количество хранимых сжатых логов (старые логи архивируются в tar и gzip); максимальный размер файла лога; количество хранимых сжатых фрагментов (очень старые записи будут удаляться); так же можно настроить периодичность запуска ротирования и даже отправку сообщений по почте, но главная функция - следить за размерами логов.
Так же примечательно, что можно настраивать разные параметры ротирования для конкретных файлов логов.
Для опытных пользователей доступно написание скриптов prerotate и postrotate.

После установки logrotate автоматический добавиться в cron, по стандартным настройкам он будет выполняться ежедневно. Если Вы вдруг захотите изменить стандартные настройки, то найти их можно в файле /etc/cron.daily/logrotate.cron.

Главный конфигурационный файл у logrotate находится по адресу /etc/logrotate.conf. Конфиг файлы ротаций делаются в директории /etc/logrotate.d/.

**Синтаксис конфиг файлов:**

```
/var/log/wtmp {
    monthly
    create 0664 root utmp
    rotate 1
}
```

Базовым элементом конфигурационного файла является секция. Она содержит лог фаил для ротации (в нашем примере это /var/log/wtmp) и опции в фигурных скобках. Когда вы указываете опцию вне какой-либо секции, это интерпретируется как значение по умолчанию.

**Примеры:**

```
/var/log/apache2/*.log {
    weekly
    missingok
    rotate 2
    compress
    delaycompress
    notifempty
    sharedscripts
    postrotate
    if [ -f /var/run/apache.pid ]; then
      /etc/init.d/apache2 restart &gt; /dev/null
    fi
    endscript
}
```

```
/var/log/messages {
    rotate 7
    weekly
    compress
    size 50M
    notifempty
    delaycompress
    sharedscripts
    postrotate
        /etc/init.d/syslog-ng reload &gt; /dev/null 2&gt;&amp;1 || true
    endscript
}
```

Описание некоторых функций:

**compress** – сжатие лог файлов, используя gzip  
**create mode owner group** – выбираем разрешения (как и командой chmod) и владельца для ротационных лог файлов.  
**daily, weekly, monthly** (ежедневно, еженедельно, ежемесячно) – как часто логи будут ротироваться.  
**size size[G|M|k]** – ротировать, если лог файл превысил размер в байтах / килобайтах / мегабайтах / гигабайтах  
**mail address** – отправлять логи по выбранному адресу почты  
**olddir directory** - переносить отратированные логи в другую директорию  
**rotate count** – вести учёт отратированых лог файлов  
ну, а если хотите знать больше, то man logrotate

Опции команды logrotate  
**-d, --debug** -ничего не делать, просто выполнить тест или отладку (совместно с -v).  
**-f, --force** -начать работу, даже если время еще не пришло.  
**-m, --mail=command** -указать команду для отправки электронной почты.  
**-s, --state=statefile** -использование альтернативного файла состояния.  
**-v, --verbose** -выводить отладочную информацию.  

###  С помощью newsyslog
Newsyslog обычно запускается по cron’у раз в час, читает конфигурационный файл /etc/newsyslog.conf и определяет, когда лог-файлы нуждаются в архивировании и перегруппировке. logfile перемещается в logfile.0, logfile.0 перемещается в logfile.1, и так далее. Другое именование получится при архивировании с помощью gzip: logfile.0.gz, logfile.1.gz, и т.д.

Конфигурационный файл newsyslog.conf указывает, какие лог-файлы должны быть проинспектированы, сколько их должно быть сохранено, а также, когда они должны быть пересмотрены. Лог-файлы могут быть перегруппированы и/или заархивированы исходя из заданных параметров:
1. когда они достигнут определённого размера;
1. при достижении определённых даты/времени.

Для примера, "кусочек" newsyslog.conf на одном из серверов:
```
# logfilename          [owner:group]    mode count size when  flags [/pid_file] [sig_num]
/var/log/all.log                        600  7     *    @T00  J
/var/log/amd.log                        644  7     100  *     J
/var/log/auth.log                       600  7     100  *     JC
/var/log/console.log                    600  5     100  *     J
/var/log/cron                           600  3     100  *     JC
/var/log/daily.log                      640  7     *    @T00  JN
/var/log/debug.log                      600  7     100  *     JC
/var/log/kerberos.log                   600  7     100  *     J
/var/log/lpd-errs                       644  7     100  *     JC
/var/log/maillog                        640  7     *    $W6D0 JC

**Описание:**

**лог-файл** - абсолютный путь к лог-файлу;  
**[владелец:группа]** - необязательный параметр, который указывает newsyslog’у кто должен являться владельцом данного лог-файла ;  
**права** - права, которые необходимо выставить на файл;  
**количество** - максимальное количество заархивированных лог-файлов;  
**размер** - по достижению какого размера архивировать лог-файл;  
**когда** - время, через которое архивировать лог-файл;  
**флаги** — некоторые дополнитпараметры, для лог-файлов:  
**B** - по умолчанию, newsyslog добавляет в новый лог-файл сообщение о том, что лог-файл был ротирован, но если лог-файл бинарный, то это сообщение испортит лог, с параметром B newsyslog не будет добавлятьт никаких сообщений в лог  
**C** - если лог-файл не существует, то его необходимо создать.  
**G** - если указан данный флаг, то в названии лог-файла можно использовать стандартные шаблоны(например *)  
**J** - сжимать лог-файл, используя bzip2  
**N** - Не предупреждать никакой процесс, о ротации лог-файла  
**W** - если используете флаги Z или J, то newsyslog должен подождать, пока заверщиться процесс архивации.  
**Z** - сжимать лог, использую gzip.  

Предлагаю рассмотреть более подробно синтаксис конфигурационного файла.

logfilename - указывается полное имя файла журнала, например /var/log/httpd-error.log. Здесь все понятно

[owner:group] - как уже писалось - необязательная опция. Это список из владельца и группы файла, разделенных двоеточием. Вот так: "root:wheel". Newsyslog может изменять владельца и группу также и старых файлов журналов. По умолчанию владельцем устаревших журналов является пользователь root, группы wheel. Эту возможность вы можете с успехом применять на многопользовательских машинах. Также есть возможность указать изменение только владельца, или только группы. В этом случае необходимо использовать двоеточие с пустым местом там, где должен находиться неизменяемый параметр. Например ":www" сменит группу на "www", а "username:" заменит владельца на "username".

mode - здесь проблем не должно быть. Указываем режим доступа к устаревшим файлам журналов в стандартном трехциферном Unix-формате.

count - счетчик, указывающий newsyslog на количество хранимых устаревших журналов. Newsyslog начинает отсчет файлов с нуля. В то время как большинство программ начинают считать с нуля, newsyslog включает 0 «по умолчанию», и считает файлы не учитывая нулевой. По умолчанию для журнала /var/log/massages счетчик равен пяти, при этом /var/log содержит следующие файлы:

  messages
  messages.0.gz
  messages.1.gz
  messages.2.gz
  messages.3.gz
  messages.4.gz
  messages.5.gz

Те из вас, кто может сосчитать количество файлов, видят, что их шесть, а не пять, плюс еще и текущий файл журнала. Как правило, иметь большее количество журналов лучше, чем испытывать в них недостаток . В то же время, если присутствует недостаток свободного пространства на винчестере, то иногда вы будете испытывать искушение удалить один-два излишних журнала. Похожая ситуация возникает в основном на веб-серверах, где размещено до нескольких сотен сайтов – несколько удаленных журналов каждого сайта в сумме могут составить достаточно большой объем свободного места.

size  и when - поля конфигурационной записи указывают newsyslog размер и/или  время, при наступлении которых указанный файл необходимо подвергнуть ротации. Можно осуществлять ротацию по достижении определенного объема файла, или при наступлении определенного времени, или в обоих случаях. Если указаны оба условия, то ротация будет происходить при выполнении любого из них.

Если размер или время не важны, то устанавливаем "*", то есть "любое значение". Например, если вы хотите проводить ротацию независимо от размера файла, то вместо указания размера необходимо поставить звездочку "*".

Поле size используется для указания размера в килобайтах. Когда newsyslog запускается он сравнивает размер файла с указанным, если файл больше, то производится его ротация.

Поле when, указывающее время, заставляет плакать новичков в системном администрировании. Поле времени может содержать данные четырех типов: «звездочку», число или два различных формата даты.

Если вы не хотите производить ротацию журналов в определенное время, просто поставьте в это поле «звездочку».

Если в поле будет число, то newsyslog будет проводить ротацию по прошествии указанного количества часов. Например, если вы хотите, что бы ротация проводилась каждые 24 часа, и вам не важно в какое именно время, то просто поставьте в это поле число «24».

Если поле начинается символом «@», то считается что время представлено в формате ISO-8601. Этот стандарт используется newsyslog в большинстве Unix-подобных операционных систем. Этот формат использовался первой версией newsyslog разработанной в MIT (Массачусетский Технологический Институт – прим. переводчика). На первый взгляд этот формат не совсем понятен. Но, поскольку это стандарт, FreeBSD его поддерживает.

Полная запись даты в формате ISO-8601 состоит из 16 цифр с буквой «T» в середине. Первые четыре цифры означают год, следующие две – месяц, и еще две – день месяца. Буква «T» идет после даты, отделяя ее от времени, как десятичная точка в вещественных числах отделяет дробную часть от целой. После буквы «T» идут две цифры часа, затем две цифры минут и наконец две цифры секунд. Например дата 2 февраля 2002 года, 21:15:08, в формате ISO-8601будет выглядеть следующим образом:

20020202T211508

Вы обязательно должны ставить букву «T» в ISO-8601-дате.

Указание полных дат в формате ISO-8601 просто и очевидно. Путаница начинается, когда вы не пишете полную дату. Вы можете указать поля даты только рядом с буквой «T», оставив остальное место незаполненным. Все неуказанные поля не будут учитываться при сравнении.

Например T23 значит – любой день в году, 23:00. Если вы напишете в newsyslog.conf @T23, то ротация этого журнала будет проводиться каждый день, ровно в 23:00. Запись 4T00 значит полночь 4 числа каждого месяца, таким образом @4T00 будет запускать ротацию в это время.

Так же как при работе с crontab вам следует уточнить часы ротации. Указание даты типа @7T будет запускать ротацию один раз в час, каждый час седьмого числа каждого месяца. Таким образом такая дата будет запускать ротацию раз в час на протяжении целого дня. Это может быть полезно для отладки, но вряд ли пригодится в реальной жизни.

Эта система имеет одну серьезную проблему – она не дает простого способа задавать ежедневно выполняемые задачи. Желание запустить ротацию журнала по понедельникам, не является чем-то необычным. Запустить ротацию журнала в последний день месяца таким образов вообще не удастся. Тут на помощь приходит второй формат времени.

Если запись времени начинается со знака доллара "$", то считается, что время задается в специфическом FreeBSD-формате «месяц-неделя-день». Это очень похоже на cron и позволяет вам установить конкретные дни недели для выполнения задачи.

Этот формат использует три буквенных идентификатора: M (день месяца), W (день недели), H (час дня). После каждого из них идет число, указывающее точное время запуска. Часы находятся в интервале от 0 до 23, дни недели от 0 (воскресенье), до 6 (суббота). Дни месяца: от 1 и до количества дней в конкретном месяце.

Например для запуска ротации каждое воскресение в 8 утра вам следует задать время как $W0H8. Если вы захотите ротировать журналы в полдень 5 числа каждого месяца, то напишите $M5H12.

Одна интересная функция этой системы позволяет вам автоматически задавать ротацию на последний день месяца используя специальный «день месяца» – «L» (от last – последний). Без этого знака было бы очень трудно задать ротацию журнала в последний день месяца без написания скрипта, который бы вставлял количество дней в конкретном месяце. Если вы хотите запустить ротацию вашего журнала аккаунтов за два часа до начала нового месяца, вы должны использовать запись $MLH22.

flags - это поле необязательно для большинства журналов, однако для некоторых оно жизненно важно.

Newsyslog вставляет сообщение «logfile turned over» в каждый вновь созданный файл журнала. Если журнал ведется в двоичном виде (как например /var/log/wtmp), то добавление такого сообщения обязательно его испортит. Флаг «B» запрещает newsyslog'у вставлять это сообщение.

Большинство журналов ведется в текстовом формате. Сжатие таких файлов сохранит много пространства на вашем диске. Флаг «Z» укажет newsyslog, что старые журналы следует сжать gzip'ом, «J» - bzip'ом.

Одновременно допускается использовать только один из этих флагов.

Флаг D предотвращает создание ново пусто файл журнала. Это может быть полезно, чтобы избежать загромождения каталогов с файлами, которые никогда не будут использоваться, или когда демон создает свой собственный лог-файл(ы) по запросу (отказ от использования этого флага в последнем случае может привести к ложным предупреждениям). Заметим, что этот флаг не следует использовать с такими демонами, как Syslogd которые требуют, чтобы лог-файл существовал.

Флаг 0 означает, что последний архив файла журнала (т.е. тот, который заканчивается на ".0";) не должен быть сжат, даже если уствновлен флаг Z. Этот флаг также делает его более удобным для просмотра последних архивных лог-файл без необходимости сначала распаковать его или использовать такие инструменты, как zmore, или zgrep и т.д.

- Флаг ничего не значит, но может быть использован в качестве заполнителя, когда один или оба path_to_pid_file и sigtype полей указаны для записи без каких-либо флагов.

 [/pid_file] - задает путь к «pid-файлу» процесса пишущего журнал. Использование pid-файлов является простым способом записи поля ID процесса в системе, так что бы другие программы могли его легко прочитать. Большинство программ хранят свои pid-файлы в каталоге /var/run – поглядите у себя на машине. Если в этом поле вы укажете полный путь к pid-файлу, то newsyslog будет посылать сигнал этому процессу когда будет производиться ротация. Например веб-сервер Apache должен быть оповещен при ротации его журналов. Записав в этом поле полный путь к его pid-файлу вы заставите newsyslog посылать процессу Apache сигнал kill -1, что бы он запустил свою часть обработки ротации журналов.

[sig_num]  - большинство программ поддерживают ротацию журналов сигналом kill -1 или SIGHUP. Некоторые программы требуют специального сигнала, когда их файлы ротируют. Если вы используйте программу такого типа, то укажите номер необходимый сигнал в последнем поле.

Давайте соберем все сказанное вместе, в самом худшем случае, в примере, в который трудно поверить. Итак у вас есть журнал базы данных, который вы хотите ротировать в 23 часа в последний день каждого месяца. В документации базы данных сказано, что вы должны послать процессу базы сигнал прерывания (SIGINT или сигнал номер 2) после ротации. Вы хотите, что бы архивные журналы принадлежали пользователю "dbmanager" и читать их мог только он. Более того, журналы – двоичные файлы и должны быть не тронуты newsyslog'ом. Ваш newsyslog.conf должен выглядеть следующим образом:

  /var/log/database dbmanager: 600 30 * $MLH23 B /var/run/db.pid 2

##  Анализ журналов с помощью Logcheck
Конечно же, ведение журналов это только полдела. Приложение наподобие Logcheck может значительно облегчить регулярный анализ журналов. Logcheck это сценарий, который вместе с двоичным файлом logtail, запускается службой cron и сверяет журналы с заданными правилами на предмет подозрительной деятельности. При совпадении он отправляет электронное письмо с соответствующими записями на почтовый ящик администратора.

Logcheck и logtail входят в состав пакета app-admin/logsentry.

Logcheck использует четыре файла для выделения важных событий из обычных сообщений. Этими файлами являются logcheck.hacking, содержащий известные сообщения, встречающиеся при взломе, logcheck.violations, содержащий шаблоны, сигнализирующие о нарушениях безопасности, logcheck.violations.ignore, содержащий ключевые слова, совпадающие с шаблонами в файле нарушений, но которые можно игнорировать, и logcheck.ignore, содержащий записи, которые можно игнорировать.

<html>
<span style="color:red">Не оставляйте logcheck.violations.ignore пустым. Для обработки журналов Logcheck использует grep, некоторые версии которого считают пустой файл знаком подстановки (wildcard). В таком случае все нарушения будут игнорироваться.</span>
</html>

##  Ссылки:
[]()[http://rus-linux.net/nlib.php?name=/MyLDP/consol/HuMan/logger-ru.html|Bash скрипты: Пишем в системные логи]()  
[]()[http://www.linuxcenter.ru/enc/proc.phtml|Демоны системного протоколирования]()  
[]()[http://www.winsov.ru/linux020.php|Cистемное протоколирование в Linux]()  
[]()[http://www.hilik.org.ua/newsyslog-настраиваем-ротацию-логов/|newsyslog. Настраиваем ротацию логов.]()  
[]()[http://www.hilik.org.ua/rsyslogd-установка-и-настройка/|Rsyslogd. Установка и настройка.]()  
[]()[http://www.k-max.name/Linux/syslogd-and-logrotate/|Системные журналы Linux (управление логированием)]()  
http://www.rusdoc.ru/articles/15816/  
http://www.opennet.ru/base/net/remote_log_mon.txt.html  
http://www.getinfo.ru/article565.html  
http://www.lissyara.su/articles/freebsd/tuning/newsyslog/  
http://www.bog.pp.ru/work/syslog.html

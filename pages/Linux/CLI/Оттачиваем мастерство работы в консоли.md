# Оттачиваем мастерство работы в консоли.
После того, как у меня появился новый монитор на рабочем месте, я начал новую итерацию улучшения своего «безмышечного» (mouse-less, прим. пер.) опыта. Вы же знаете, что это значит, не так ли? Это значит, что каждый раз, когда вы беретесь за мышку, убирая руку с клавиатуры, вы тратите немного времени и энергии. Если вам нужно набирать много текста (а я много пишу кода), это становится существенным.

Так же существует следующий уровень «безмышечного» опыта, когда вы стараетесь избежать труднодоступных клавиш, например `Delete`, `Backspace`, `Escape` или даже `Enter`.

Если вы держите руки в стандартной позиции для 10-пальцевой слепой печати, более удобно нажать `Ctrl-m` вместо того, чтобы тянуться мизинцем к энтеру.

![](/images/Linux/Shell/QWERTY-home-keys-position.svg)

В этой статье я расскажу про удобные сочетания клавиши, которые можно использовать в любом терминале, хоть они работают и в многих других местах.

Для начала, сравнительная таблица:

| Действие                      |     Клавиши   |           Алтернатива |
|-------------------------------|--------------:|----------------------:|
| Начало строки                 |        `Home` |              `Ctrl-a` |
| Конец строки                  |         `End` |              `Ctrl-e` |
| Один символ вперед            | `Right Arrow` |              `Ctrl-f` |
| Один символ назад             |  `Left Arrow` |              `Ctrl-b` |
| Удалить символ под курсором   |      `Delete` |              `Ctrl-d` |
| Удалить символ перед курсором |   `Backspace` |              `Ctrl-h` |
| Предыдущая команда в истории  |    `Up Arrow` |              `Ctrl-p` |
| Следующая команда в истории   |  `Down Arrow` |              `Ctrl-n` |
| Ввод команды                  |       `Enter` | `Ctrl-j` или `Ctrl-m` |

Как бонус, вот еще список удобных сочетаний:

| Действие                     | Клавиши  |
|------------------------------|----------|
| Вырезать предыдущее слово    | `Ctrl-w` |
| Вырезать все к концу строки  | `Ctrl-k` |
| Вырезать все к началу строки | `Ctrl-u` |
| Вставить вырезанное ранее    | `Ctrl-y` |
| Откатить изменение           | `Ctrl-_` |
| Очистить экран               | `Ctrl-l` |

Не забудьте попробовать эти сочетания в других приложениях. Я думаю, вы удивитесь, насколько широко они поддерживаются.

## Почему это работает

Прежде всего, существует широко используемая библиотека `readline`. Попробуйте удалить ее из вашей системы, и вы узнаете, сколько приложений от нее зависят (ЭТО БЫЛА ПЛОХАЯ ШУТКА. НЕ ДЕЛАЙТЕ ЭТО). Из официальной домашней страницы:

> Библиотека GNU Readline предоставляет набор функций, позволяющих пользователю редактировать вводимые команды прямо в месте ввода.

Это значит, что приложение может просто использовать эту библиотеку для пользовательского ввода, и она позаботится обо всех «плюшках». Из официальной документации вы можете узнать, что она поддерживает `emacs` и `vi` режимы, где первый идет по умолчанию. `Vi` режим более знаком виммерам, однако есть один существенный недостаток: нет индикатора текущего режима.

`readline` предоставляет большинство сочетаний, но не все. Среди них есть `Ctrl-h`, `Ctrl-m`, `Ctrl-j`. Но почему они работают? Я думаю, вам понравится ответ.

Помните ли вы таблицу `ASCII` символов? Там еще в начале таблицы есть 32 старых ненужных управляющих символов. И если вы посмотрите на сочетание   `Ctrl-m` с помощью утилиты `xev`, то увидите,

```js
KeyRelease event, serial 37, synthetic NO, window 0x2000001,
    root 0x4b0, subw 0x0, time 27612296, (-545,367), root:(958,388),
    state 0x14, keycode 58 (keysym 0x6d, m), same_screen YES,
"   XLookupString gives 1 bytes: (0d) "
    XFilterEvent returns: False
```

что `XLookupString` возвращает `0x0d` байт для этого сочетания. А `0x0d` байт это не что иное, как управляющий символ возврата каретки, так же известный как `\r`. Этот управляющий символ говорит терминалу принять вашу команду, работая так же, как и `Enter`. Так что, управляющие символы не такие уж и ненужные (ну, по крайней мере часть из них).

Другой интересный вопрос, как же система определяет связь между `Ctrl-m` сочетанием и символом возврата каретки. Ответ на это не менее интересный — `Caret notation`: метод записи управляющих символов с помощью печатных. Правило очень простое: просто инвентируйте седьмой бит в коде управляющего символа, и получите соответствующий печатный. С одной стороны, все просто; с другой, нельзя переназначить. Но не верьте мне, проверьте сами здесь.

На этом все. Я надеюсь, материал был полезный. Совершенствуйтесь!

P.S. Индикатор режима в `readline` все-таки присутствует, начиная с версии 6.3. Для этого нужно добавить `set show-mode-in-prompt` On в `~/.inputrc`.
P.S.S.Таблицу `ascii` кодов можно посмотреть командой `man ascii`.




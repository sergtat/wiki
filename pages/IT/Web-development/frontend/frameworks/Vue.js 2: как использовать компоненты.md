# Vue.js 2: как использовать компоненты.
Компоненты продолжают идею плагинов. Если нужна какая-то возможность, то часто уже есть и плагин, реализующий её (конечно можно написать и свой). Когда понадобится в другом месте — легко переиспользовать плагин снова. Взаимодействие основано на простом интерфейсе: отправляем в плагин входные параметры, а для обратной связи отслеживаем события.

Всё это применимо и к компонентам. Отличие в том, что компонент может представлять собой не только одну вещь (например, красивый и функциональный select), но и какую-то часть приложения, которая должна работать и выглядеть везде единообразно (например, форма комментирования, с аватаркой, редактором и красивым select’ом).

![Vue.js 2: как использовать компоненты](/images/Webd/vue2_001.png 'Vue.js 2: как использовать компоненты')

С компонентным подходом можно избежать мешанины кода чётко выстраивая архитектуру приложения. Любую сложную страницу можно разделить на составляющие. Каждую из таких частей делать компонентом и при необходимости повторять разделение на ещё меньшие составляющие.

Это очень удобно в поддержке — не нужно держать в голове логику всего приложения, можно сосредоточиться на конкретной его части. Изменения нужно вносить только в одном месте. А изолированность избавляет от появления конфликтов с другими частями приложения.

Полагаю отчасти от возможности использовать компонентный подход стали широко популярны React и Angular. Vue.js не остался в стороне и предоставляет прекрасные возможности по работе с компонентами.

## Компонент и его структура

В разметке компоненты выглядят как нестандартные теги (например, `<comment-form></comment-form>`). Отличие компонента от обычного тега в том, что он может “скрывать” под собой любую разметку, логику работы и подключение других компонентов.

Описывать логику компонентов можно и на страницах. В этом случае есть некоторые ограничения по использованию и именованию (для браузера всё должно быть валидным кодом). Vue.js также имеет поддержку JSX.

Самый удобный и богатый на возможности формат — vue-файлы. Всё связанное с компонентом собрано в одном месте. Структурно файл состоит из трёх частей:

- `<template>` для шаблона разметки
- `<script>` с логикой компонента
- `<style>` со стилями компонента

При желании составляющие можно вынести в другие файлы:

```html
<template src="./template.html"></template>
<style src="./style.css"></style>
<script src="./script.js"></script>
```

![Vue.js 2: как использовать компоненты](/images/Webd/vue2_002.png 'Vue.js 2: как использовать компоненты')

На примере выше можно подметить и другие приятные возможности `vue-loader`, например использование `Jade` и `SASS`, а с помощью других loader’ов для webpack можно использовать любые комбинации.

## Настройка webpack для компонентов

Для работы с vue-файлами минимально нужны webpack и vue-loader. Добавляем правило для обработки vue-файлов в webpack.config.js:

```javascript
...
rules: [
    ...
    {
        test: /\.vue$/,
        loader: 'vue-loader',
    }
    ...
]
...
```

Для удобства можно поставить ещё и webpack-dev-server. Кстати компоненты поддерживают горячую замену модулей. Также на посмотреть и поиграться существует vue-webpack-boilerplate. А для красивой подсветки кода в редакторе плагины (Sublime Text, Atom).

_Как правильно настроить webpack для работы с разношёрстным содержимым vue-файлов понимание ещё не пришло (прогонять все vue-файлы через все возможные loader’ы кажется неправильным)._

**Обновление 18.12.2016**: разобрался [как правильно настраивать Webpack & vue-loader](./Vue.js\ 2:\ Webpack\ и\ vue-файлы\ с\ разными\ типами\ содержимого.md)

## Старт с vue-компонента

Если хочется начинать сразу с файла-компонента без дополнительной разметки и шаблонов, то нужно импортировать компонент и указать его в методе `render`:

```javascript
import Vue from 'vue';
import App from './App.vue';

new Vue({
  el: '#app',
  render (h) {
    return h(App)
  }
});
```

## Регистрация компонента

Так как компоненты независимы, то в какой-то момент нужно “рассказывать” одному о существовании другого.

Компонент можно зарегистрировать глобально или локально. При первом варианте — компонент регистрируется после подключения `Vue.js`, но до создания нового инстанса `Vue`:

```javascript
// ... где-то раньше подключаем Vue.js

Vue.component('test-component', {
    // настройки компонента
});

// ... где-то потом будет new Vue({…});
```

Второй вариант — локальная регистрация. В этом случае вызов компонента будет доступен только в области видимости своего родителя. В секции `components` перечисляем какие используем компоненты и под какими именами:

```javascript
<script>
    // Подключаем файл компонента
    import testComponent from './test-component.vue';

    // или можно так
    var testComponent = require('./test-component.vue');

    export default {
        ...
        // указываем используемые компоненты
        components: {
            'test-component': testComponent,
            'another-test': ...
        }
        ...
    }
</script>
```

С ES6 можно немного сократить запись:

```javascript
import testComponent from './test-component.vue';

...
components: {
    testComponent
}
...
```

## Вызов компонента

После подключения и регистрации компонентов можно начинать использовать их в шаблоне:

```html
<template>
    ...

    // Используем компонент
    <test-component></test-component>

    // ... или так   
    <testComponent></testComponent>

    // ... или даже так
    <div is="testComponent"></div>
    <component is="testComponent"></component>

    ...
</template>
```

Последние два варианта используют специальный атрибут `is` для указания имени компонента. Вообще он задумывался как средство для обхода ограничений при использовании DOM в качестве шаблона, так как браузер удаляет весь невалидный код при парсинге. Но в нашем проекте решил использовать последний вариант с тегом component. Это выглядит нагляднее для всех, сразу заметны и легко найти все вызовы компонентов в шаблоне, а также быстро можно переключить на динамический выбор компонента.

## Динамический выбор компонента

Случается что нужно показывать по условию один из нескольких компонентов. Как это сделать? Можно например воспользоваться условным рендерингом:

```html
<div v-if="component1or2">
    <component is="component1"></component>
</div>
<div v-else>
    <component is="component2"></component>
</div>
```

Но чем больше вариантов выбора, тем увеличивается количество лишней разметки. Вновь пригодится специальный атрибут is. Ему указывается строка с именем компонента. Но с помощью `v-bind` можно привязать к атрибуту уже результат вычисления, например вычисляемой переменной, что вернёт строку с нужным названием компонента:

```html
// selectComponent вернёт строку с нужным названием компонента
<component v-bind:is="selectComponent"></component>

// сокращённый вариант
<component :is="selectComponent"></component>
```

В результате никакой лишней разметки, а выбор нужного компонента полностью вынесен в логику и может быть сколь угодно изощрённым.

## Передача данных в компонент

Не все компоненты работают сами по себе. Большей части требуются входные данные, на основании которых они выполняют свою логику, генерируют шаблон и, возможно, передают часть в используемые ими компоненты.

Для передачи данных достаточно привязки к именованному атрибуту. Например, для передачи данных из `testList` под именем `list`:

```html
// Передаём в компонент
<test-component v-bind:list="testList"></test-component>

// Сокращённый вариант
<test-component :list="testList"></test-component>
```

Чтобы дочерний компонент смог ими воспользоваться нужно и в нём указать под каким именем ожидать входные данные:

```javascript
<script>
    export default {
        props: ['list']
        ...
    }
</script>
```

Можно передавать и несколько разных данных:

```html
// Несколько наборов данных
<test-component :list="testList" :flag="isOk"></test-component>

...

// ... в дочернем компоненте
props: ['list', 'flag']
```

## Отслеживание событий в компоненте

По-началу это казалось немного неочевидным, но на деле оказалось удобным способом отслеживания событий в дочернем компоненте:

```html
// Отслеживание события click в дочернем компоненте
<test-component v-on:click="clickHandler"></test-component>

// сокращённая запись
<test-component @click="clickHandler"></test-component>

// ... можно отслеживать и пользовательские события
<test-component @remove="removeHandler"></test-component>
<test-component @filter="filterHandler"></test-component>
```

Кроме самого факта события можно передать и данные:

```javascript
// ... в дочернем компоненте
// генерируем событие remove и передаем ID
this.$emit('remove', id)
```

В родительском компоненте останется просто добавить параметр:

```javascript
// ... в родительском компоненте
methods: {
    removeHandler (id) {...}
}
```

Надеюсь, это поможет начать работать с компонентами!

**Источник**: https://medium.com/

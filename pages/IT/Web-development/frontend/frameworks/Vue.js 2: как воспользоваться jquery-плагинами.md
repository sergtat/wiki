# Vue.js 2: как воспользоваться jquery-плагинами.
**_несколько простых примеров_**

Vue.js предполагает, что шаблон всего лишь декларативная привязка к данным, и рассчитывает что заниматься DOM нам не потребуется. Это замечательно, но если вот потребуется какая-то фишка, которая уже встречалась ранее в виде jQuery-плагина. Как им воспользоваться?

Начать лучше с поисков, вдруг кто-то уже сделал компонент для такого или компонент-обёртку для плагина. Вот несколько сайтов что удалось найти с подборками для Vue.js:

- http://vuejsexamples.com/
- https://github.com/vuejs/awesome-vue (секция UI Components)

Стоит обращать внимание для какой версии Vue.js компонент: не факт, что компоненты для Vue.js 1.х без проблем заработают на Vue.js 2.х.

А если компонента нет, автор обещает выпустить обновление когда-нибудь потом, а возможность уже нужна? Вариантов тут два: написать собственный компонент или воспользоваться плагином.

## Плагины только для отображения данных

Часть плагинов используется только для какого-то особенного отображения уже существующих данных. В этом случае логика использования jQuery-плагина в связке с Vue.js достаточно проста.

В файле компонента подключаем jQuery (или подключаем глобально) и сам плагин. Дальше в секции `mounted` компонента вызываем плагин с нужными нам настройками и данными из Vue. Будет выглядеть примерно так:

```javascript
import $ from 'jquery';  // подключаем jQuery
import 'whateverplugin'; // подключаем сам плагин
...

export default {
  data () {
    return {
      options: [...]
    };
  },
  ...

  mounted () {
    $('#plugin-container').whateverplugin({
       ...
       // передаем в плагин нужные данные
       options: this.options
       ...
    });
  }
}
```

Готово! Но что если нам требуется обратная связь от плагина?

## Плагины, работающие с данными

Это могут быть например плагины-обёртки для полей. Возьмём например поле, которое связано через `v-model`. В самом счастливом случае плагин после своих правок корректно синхронизирует новое значение с оригинальным полем и Vue.js это заметит и тоже обновит.

К сожалению это редкость, поэтому нужно посмотреть на возможности плагина как можно отслеживать производимые в нём изменения. Суть в том, чтобы после изменений получать новые данные и сохранять обратно в Vue.

### Summernote

[Summernote](http://summernote.org/) - Super Simple WYSIWYG editor

_Super Simple WYSIWYG Editor on Bootstrap Summernote is a JavaScript library that helps you create WYSIWYG editors…_

Например, на текстовое поле хочется добавить простой текстовый редактор. В `template` уже есть текстовое поле, связанное с моделью и `id` к которому будем подцеплять плагин:

```html
<template>
  ...
  <textarea id="editor" v-model="text"></textarea>
  ...
</template>
```

В секции `mounted` компонента подключаем плагин:

```javascript
<script>
import $ from 'jquery'; // ... jquery
import 'summernote';    // ... сам плагин
...

...
mounted: function(){
  $('#editor').summernote({
    // ... настройки плагина
  });
}
...
</script>
```

Плагин будет работать, но любые изменения никак не будут отражаться на данных. Как же сохранять данные обратно? Summernote поддерживает callback `onChange`, который будет вызван после каждого изменения содержимого редактора. В него и добавляем сохранение данных обратно в Vue:

```javascript
...
mounted: function() {
    var $vm = this; // сохраняем ссылку на Vue

    $('#editor').summernote({
        // ... настройки плагина
        callbacks: {
            onChange: function(contents) {
                $vm.text = contents; // сохраняем новые данные
            }
        }
    });
}
...
```

Так как наша анонимная функция в `onChange` создаёт свой собственный контекст, то `this` уже не будет указывать на Vue. Чтобы это исправить, просто сохраняем ссылку на Vue в переменную.

### Selectize.js

[selectize.js](https://github.com/selectize/selectize.js) - Selectize is the hybrid of a textbox and &lt;select&gt; box. It&#39;s jQuery based and it has…

Ещё один похожий пример, но допустим есть возможность использовать ES6. Немного упростить код помогут стрелочные функции, которые не создают свой контекст. Сохранять ссылку на Vue не потребуется:

```javascript
...
mounted () {
  $('#town-picker').selectize({
      // ... настройки плагина
      onChange: (value) => {
          this.field = value;
      }
  });
}
...
```

В таком случае сохранять ссылку на Vue не потребуется.

P.S.: Также пока не слишком понятно, необходимо ли уничтожать плагины перед уничтожением компонента в секции beforeDestroy? Например у selectize.js есть метод `destroy` для такого:

```javascript
...
beforeDestroy () {
  $('#town-picker')[0].selectize.destroy();
}
...
```

В каких-то плагинах такая возможность встречается, в других нет. Думаю хуже от этого не будет.

**Источник**: https://medium.com

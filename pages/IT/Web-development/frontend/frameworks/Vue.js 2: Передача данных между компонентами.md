# Vue.js 2: Передача данных между компонентами.
**_или отправка данных с помощью событий_**

Компонентный подход — это хорошо. Логика чётко разделена между частями приложения, всё изолировано друг от друга, а части знают лишь о том, о чём им нужно знать. Данные передаются сверху вниз через `props`, которые только для чтения. Но ведь нужна и обратная связь. Как же передавать информацию обратно, наверх?

Для примера возьмём два компонента: список и элемент списка. Каждый в своём `.vue` файле. Глобально они не зарегистрированы: родительский узнаёт о дочернем из своей секции `components`.

В родительском указана логика работы со списком: как загружать, как добавлять элемент и как удалять из него. Дочерний занимается только тем как показывать сам элемент списка.

И, например, в дочернем элементе списка есть кнопка удаления. Нужно по нажатию кнопки удалять этот элемент из списка. Сам элемент себя не удалит, он даже не знает о списке и о том какой он там по счёту. Надо как-то уведомить о нашем желании родительский компонент и заодно передать `id`, для ясности кого удалять.

По мере изучения документации, гуглений и тому подобных экспериментов нашлось несколько разных решений этой задачи.

## Вызов родительского метода из дочернего компонента

Первый рабочий вариант — добавить на кнопку удаления вызов непосредственно родительского метода:

```javascript
this.$parent.$options.methods.removeFromList(id);
```

Чем плох этот вариант? Дочерний компонент становится явно зависим от родительской логики. Любые изменения и рефакторинг родительского компонента надо делать учитывая, что где-то ещё и в дочерних компонентах надо вносить изменения. Такой хардкод наставит палок в колёса, когда всё это успешно забудется, да и если захочется переиспользовать компонент где-то ещё.

## Генерация события в родительском компоненте из дочернего

Официальная документация предлагает пользоваться событиями: один компонент их генерирует, другой слушает и уже сам как-то занимается обработкой. Кстати из события можно получить и доступ к DOM-элементу, его вызвавшего, что может быть иногда полезным:

```javascript
// Генерируем событие, возможно с передаваемыми данными
this.$emit('название' [, данные]);

// Слушаем событие
this.$on('название', function(данные) {...});
```

В документации описаны самые простые случаи: генерация события и его прослушивание находится в одном файле. Это меня немного сбило с толку как сделать подобное с разными файлами компонентов.

Основываясь на “опыте” предыдущего способа пришла идея “вылезать наверх” из дочернего в родительский компонент и уже на уровне выше генерировать событие:

```javascript
this.$parent.$emit('remove', id);
```

В родительском же компоненте в секции `mounted` прослушивать события нужного типа:

```javascript
this.$on('remove', function (id) {...})

// ... или даже сразу вызывать нужный метод
this.$on('remove', this.removeFromList);
```

Вроде стало получше. Событие генерируется, родитель его “слышит”, `id` передаётся, связанность компонентов стала меньше, теперь нет явных указаний на метод. Ну а в callback можно уже вызвать метод, который и займётся удалением элемента из списка.

## Генерация события в дочернем компоненте и обработка в родительском

На самом деле всё оказалось ещё проще. Только вот не сразу до этого дошёл. В дочернем компоненте, также на кнопку навешиваем генерацию события:

```javascript
this.$emit('remove', id);
```

А в родительском компоненте чтобы отлавливать это событие надо добавить свой `v-on:название-события:`

```html
<component is="ListItem" v-on:remove="removeFromList"></component>
```

И всё! Теперь при генерации события `remove` в дочернем компоненте, родительский также отследит его и выполнит свой собственный метод `removeFromList`, любезно передав в него `id:`

```javascript
...
methods: {
   removeFromList: function (id) {...}
}
...
```

Связность между компонентами исчезла, а всё работает также прекрасно как и раньше. И переиспользовать компонент можно как угодно, навешиваясь или нет на это событие.

P.S.: Также по мере собирания всех граблей наткнулся, что не стоит называть подобные методы `delete`. Это зарезервированное слово, и поэтому с таким названием работать не будет.

P.P.S.: Есть ещё один вариант передачи данных между компонентами — шина. Причем не только из дочернего компонента в родительский, а между любыми, сколь угодно разрозненными, частями приложения. Судя по документации она будет общей для всех и на которой надо генерировать события.

```javascript
var bus = new Vue()

// in component A's method
bus.$emit('id-selected', 1)

// in component B's created hook
bus.$on('id-selected', function(id) {
  // ...
})
```

Вот только как правильно её инициализировать я не разобрался. В компоненте А добавляем генерацию события в методе, в компоненте В в секции `created` нужно добавить прослушивание. А где вот инициализировать шину? Попробовал в каждом из компонентов сделать `var bus = new Vue()` — не сработало и события между компонентами не пролетали. Может разберусь ещё…

## Обновление:

Спасибо добрым людям, подсказали в чём суть работы с шиной. Если делаем `var bus = new Vue()`, то необходимо переменную `bus` сделать глобальной для всех компонентов. Если плодить глобальные переменные не хочется совсем, а все необходимые части находятся внутри одного экземпляра `Vue`, то в качестве шины можно использовать корневой уровень:

```javascript
// Генерируем событие на глобальном уровне
this.$root.$emit('remove', id);
```

В других компонентах в секцию mounted добавляем прослушивание:

```javascript
this.$root.$on('remove', function (id) {...})
```

Отличается только тем, что в примерах раньше выбирались на уровень выше в `this.$parent`, а можем и подняться на самый верх через `this.$root`.

**Источник**: https://medium.com

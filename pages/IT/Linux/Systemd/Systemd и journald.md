# Systemd и journald.

_Systemd - это **не** система инициализации и даже не "системный менеджер" (как можно прочитать на freedesktop.org). systemd как проект --- это универсальный plumbing layer, набор служебных программ для совершенно разных задач. Основная идея этого проекта состоит в централизации управления ключевыми системными компонентами "всё в одном". Это сделано в основном для того, чтобы упростить администрирование и повысить надёжность за счёт интеграции и более тесного взаимодействия. В данном эпизоде мы рассмотрели непосредственно систему инициализации (тоже называемую systemd), её основные концепции и принципы работы._

## Особенности и преимущества systemd

1. подход, основанный на зависимостях между задачами
    - более логично, чем (например) событийный подход Upstart или ручная расстановка порядка действий из sysvinit
    - при попытке запуска некоторой задачи сначала запускаются все её зависимости; если что-то не запустилось --- цепочка действий прерывается
    - отдельно задаются зависимости требования (Wants/Requires) и зависимости упорядочивания (After/Before)
    - "врождённая" параллелизация

2. cлежение за запущеными сервисами
    - механизм cgroups для группировки процессов, принадлежащих разным сервисам
    - дочерние процессы не могут выйти из-под контроля
    - для инспекции дерева cgroups предусмотрены утилиты `systemd-cgls`, `systemd-cgtop`
    - появляется возможность иерархичного задания общих ограничений по ресурсам (потреблению памяти, CPU и т.д.)
    - элементы супервизора (задание действий при падении, автоматический перезапуск, сторожевые таймеры)
3. взаимодействие с udev (как пример --- [файл с правилами](http://cgit.freedesktop.org/systemd/systemd/tree/rules/99-systemd.rules.in) из поставки systemd)
    - устройство = юнит (для устройств, помеченных `TAG+="systemd"`, создаются `.device`-юниты, см. ниже)
    - из правил udev возможен также запуск произвольных юнитов (`ENV{SYSTEMD_WANTS}+="foo.service"`)
4. предусмотрен ряд способов динамического запуска сервисов (наподобие xinetd), что может экономить ресурсы системы

5. значительное уменьшение роли шелл-скриптов при загрузке системы вплоть до полного избавления от таковых (стоит отметить, что никаких ограничений на *запуск* шелл-скриптов не предполагается, речь исключительно о самом юните)

6. всесторонний и обширный D-Bus API [практически у каждого из компонентов](http://www.freedesktop.org/wiki/Software/systemd/InterfacePortabilityAndStabilityChart/)

### Юниты (units)

_Юнит --- базовая сущность, участвующая в построении дерева зависимостей_

1. один юнит --- одно действие
2. юнит может описывать не только запуск демона:
    - **service** --- демон или что-либо, что можно запустить
    - **device** --- факт подключения какого-либо устройства (имя юнита генерируется из sysfs-имени устройства)
    - **target** --- ничего не описывает, группирует другие юниты в дереве зависимостей
    - **mount** --- точку монтирования файловой системы (имя юнита должно соотвествовать пути до точки монтирования)
    - **automount** --- аналог autofs: точку автомонтирования (должен существовать \*.mount-юнит с тем же именем)
    - **timer** --- аналог cron: периодический запуск другого юнита (по умолчанию запускаться будет \*.service-юнит с тем же именем)
    - **socket** --- аналог xinetd: запуск юнита при подключении к указанному сокету (по умолчанию запускаться будет \*.service-юнит с тем же именем)
    - **path** --- запуск юнита по событию доступа к какому-либо пути в файловой системе (по умолчанию запускаться будет \*.service-юнит с тем же именем)
    - **slice** --- группирует другие юниты в дереве cgroups, позволяя иерархично задавать ограничения по используемым ресурсам

3. Юнит может быть шаблоном: если вызван юнит `foo@bar` и существует юнит `foo@`, то `bar` считается параметром и подставляется в текст юнита `foo@` вместо определённых [спецификаторов](http://www.freedesktop.org/software/systemd/man/systemd.unit.html#Specifiers) (%i и аналогичных)

4. Файлы юнитов могут храниться в трёх директориях, имеющих друг над другом приоритет:

    - `/usr/lib/systemd/system` --- "системные" юниты, поставляемые вместе с приложениями
    - `/run/systemd/system` --- динамически создаваемые (напр., через API) юниты
    - `/etc/systemd/system` --- юниты и исправления, внесённые администратором *(данная директория имеет наивысший приоритет)*

5. Посмотреть весь список и состояние юнитов можно с помощью:

    - `systemctl status` --- отображение общего состояния системы и перечисление юнитов, которым соответствуют какие-либо запущенные процессы
    - `systemctl list-units` (или просто `systemctl`) --- отображение таблицы, в которую входят все активные в данный момент или упавшие юниты *(`systemctl --failed` --- только упавшие юниты)*

6. Действия с юнитами:

    - `systemctl start ЮНИТЫ`, `systemctl stop ЮНИТЫ` --- запустить или остановить указанные юниты немедленно
    - `systemctl enable ЮНИТЫ`, `systemctl disable ЮНИТЫ` --- добавить указанные юниты в "автозапуск" или убрать их оттуда
    - *enable не подразумевает start, disable не подразумевает stop*
    - *даже если сделать disable, юнит всё равно может быть запущен как зависимость*
    - `systemctl kill [-s СИГНАЛ] [--kill-who main|control|all]` --- убить все процессы, принадлежащие юниту
    - `systemctl mask ЮНИТЫ`, `systemctl unmask ЮНИТЫ` --- замаскировать юниты (запретить их запуск любым способом, в т. ч. как зависимость) или размаскировать их

> Несколько слов про автозапуск. Концепция уровней запуска (runlevels) была заменена более общей концепцией target-юнитов: например, `multi-user.target` --- эквивалент runlevel 3.

> Поэтому добавление сервиса в какой-либо ранлевел (т. е. в автозапуск) теперь осуществляется посредством создания искусственной зависимости между нужным target-юнитом и рассматриваемым.

### Структура файла юнита.

_Формат файла юнита похож на `.desktop` (и, следовательно, на `.ini`).  Существуют две секции, допустимые в юнитах любого типа, и некоторое количество секций, специфичных для "своих" типов юнитов._

Разберём наиболее частоиспользуемые опции в трёх наиболее частоиспользуемых секциях.

1. Секция `[Unit]` --- общие параметры, применимые к юнитам любого типа.

    - `Description=` --- текстовое описание юнита
    - `Wants=`, `Requires=`, `Requisite=`, `BindsTo=` --- зависимости требования различного рода
    - `After=`, `Before=` --- зависимости порядка

2. Cекция `[Install]` --- описание автозапуска (операции enable/disable выполняют действия, описанные в данной секции).

    - **`WantedBy=`, `RequiredBy=`** --- имена юнитов, для которых нужно создавать искусственную зависимость типа Wants/Requires от этого юнита (идиома: `WantedBy=multi-user.target`)
    - **`Also=`** --- имена юнитов, для которых тоже нужно сделать enable/disable вместе с этим

3. Секция `[Service]` --- описание запускаемого процесса.

    - `Type=` --- характер запускаемого процесса:
        - forking --- демон
        - simple --- foreground-процесс (не форкается)
        - oneshot --- единовременная задача (systemd будет ждать завершения процесса)

    - `ExecStart=`, `ExecStop=` --- путь к исполняемым файлам, которые требуется запускать при старте и остановке юнита *(каждый из этих параметров опционален)*
    - `RemainAfterExit=` --- применимо только при `Type=oneshot` и определяет, считать ли юнит активным после окончания работы процесса

### Примеры вспомогательных директив.

1. `Private*=`, `ProtectSystem=`, `ProtectHome=`, `NoNewPrivileges=` --- директивы базового обеспечения безопасности
2. `MemoryLimit=`, `CPULimit=` --- управление ограничениями ресурсов
3. `User=`, `Group=` --- запуск от имени определённого пользователя

### Komaнды управления `systemd`.

1. Основная команда оценки состояния системы и управления юнитами --- `systemctl`.

    Также существуют *юниты-цели*, активация которых ничего не означает сама по себе: такие юниты используются для группировки других. Этот механизм можно назвать *обобщением концепции уровней запуска* из sysvinit.

    Подкоманды:

    - `list-units` (`--failed`) --- *(по умолчанию)* cписок юнитов (`--failed`: показывать только сбойные юниты)
    - `status` (без аргументов) --- информация о состоянии системы и список всех процессов в виде дерева по контрольным группам
    - `list-sockets`            --- список сокетов
    - `list-timers`             --- cписок таймеров
    - `daemon-reload`           --- перечитать список юнитов
    - `daemon-reexec`           --- перезапустить **сам systemd** (с сохранением состояния)
    - `show`                    --- полный список свойств юнита (машиночитаемый)
    - `cat`                     --- эффективный текст юнит-файла, включая все дополнения
    - `list-dependencies`       --- список зависимостей юнита
    - `start`                   --- запуск сервиса
    - `stop`                    --- остановка сервиса
    - `status` (с аргументами)  --- статус сервиса
    - `kill`                    --- принудительная остановка всех процессов, принадлежащих юниту
    - `reload`                  --- перезагрузка конфигурации сервиса (если это понятие к нему применимо)
    - `isolate`                 --- изолировать юнит (т. е. остановить все юниты, кроме указанного и его зависимостей)
    - `enable`                  --- "добавить в автозагрузку" (выполнить действия в `[Install]`- секции юнита)
    - `disable`                 --- "убрать из автозагрузки" (выполнить обратные действия)
    - `mask`                    --- запретить запуск юнита любым способом

    Здесь подкоманда  `status` имеет два варианта (с аргументами или без них). В первом случае выводится состояние указанных юнитов, а во втором --- общая информация о состоянии системы и дерево процессов.

    Процессы, соответствующие каждому юниту, помещаются в отдельную контрольную группу (cgroup), что значительно упрощает контроль за процессами в системе. На основе этого становится возможным отслеживать и ограничивать потребление ресурсов отдельными юнитами (а точнее, их процессами). Для этого применяются существующие механизмы в ядре Linux.

2. Команда, отображающая иерархию контрольных групп или её произвольной части --- `systemd-cgls`.

3. Команда, показывающая потребление ресурсов по контрольным группам --- `systemd-cgtop`.

    _Юниты хранятся в виде файлов с ini-подобным синтаксисом и располагаются в трёх базовых директориях, перечисленных здесь в порядке возрастания приоритета:_

    - `/usr/lib/systemd/system` --- системные юниты
    - `/run/systemd/system`     --- временные юниты
    - `/etc/systemd/system`     --- изменения, внесённые администратором

    Если файл с одним и тем же именем встречен в нескольких базовых директориях, из них выбирается наиболее приоритетный, а остальные отбрасываются. К слову, маскировка (`systemctl mask`) --- это переопределение юнита симлинком на `/dev/null`. (Из этого следует, что замаскировать юнит, находящийся в `/etc`, нельзя.)

    Впрочем, юнит-файлы можно дополнять, и не прибегая к их прямому редактированию. Для любого юнит-файла (например, `foo.service`) в любой из вышеперечисленных директорий могут быть созданы три поддиректории:

    - `foo.service.d`
    - `foo.service.wants`
    - `foo.service.requires`

    В первой из них располагаются файлы с любым именем и расширением `.conf`. Они считываются вслед за юнитом в алфавитном порядке и обрабатываются так, как будто "подклеены" в конец юнит-файла. *Секции объединяются.* При этом правила приоритета продолжают действовать: `.conf` - файлы с одинаковым именем перекрывают друг друга.

    Во второй и третьей должны находиться символьные ссылки на другие юнит-файлы. Юниты по этим ссылкам добавляются к `Wants=` и `Requires=`-зависимостям рассматриваемого юнита.

    К слову, именно таким способом обрабатываются директивы `WantedBy=` в `[Install]`-секции. Например, пусть наш юнит `foo.service` содержит `[Install]`-секцию следующего вида:

        [Install]
        WantedBy=multi-user.target

    Тогда после выполнения команды `systemctl enable foo.service` будет создана следующая символьная ссылка (предположим, что `foo.service` лежит в `/etc`):

        /etc/systemd/system/multi-user.target.wants/foo.service -> /etc/systemd/system/foo.service

    Ещё есть юниты-шаблоны. Если существует юнит `foo@.service` (знак @ в конце имени), то при обращении к `foo@bar.service` будет использоваться юнит `foo@.service`, а вхождения спецификаторов `%i` и аналогичных в его тексте будут заменены на строку **`bar`**. Да, в некоторых директивах подстановки запрещены --- список спецификаторов и ограничения проще всего посмотреть в [мане](http://www.freedesktop.org/software/systemd/man/systemd.unit.html#Specifiers).

    Теперь рассмотрим различные вспомогательные утилиты, которые systemd привносит в наш `$PATH`. Почти все они начинаются с префикса `systemd-`. Набираем этот префикс, нажимаем Tab и видим полный список. Итак,

4. `systemd-escape` и `systemd-path`.

    Про них можно сказать достаточно мало. В systemd есть собственный механизм кодирования произвольных строк в имена файлов. Он применяется в двух местах.

    **Во-первых**, имя mount-юнита должно соответствовать пути до точки монтирования (а имя device-юнита --- пути до узла устройства в `/dev` или `/sys`).

    Для того, чтобы внедрить в имя юнита произвольный путь со слешами, и применяется эта схема. Например:

    - `/` --- `-` (слеши заменяются на дефисы)
    - `/mnt/foo` --- `mnt-foo` (первый слеш пропускается, если кроме него в строке ещё что-то есть)
    - `/dev/disk/by-label/bar` --- `dev-disk-by\x2dlabel-bar` (символы со специальными значениями передаются с помощью C-подобных escape-последовательностей)

    **Во-вторых**, (почти) эта же схема может использоваться в шаблонных юнитах для того, чтобы передавать в качестве параметра произвольные строки. "Почти" заключается в том, что первый слеш не пропускается.

    Итак, утилита `systemd-escape` преобразует строки в описанный формат и обратно. Параметр `--path` включает описанную выше обработку первого слеша.

        systemctl start $(systemd-escape --path /mnt/foo).mount
        systemctl start foo@$(systemd-escape "string with 'very' (different) characters").service

    Зачем нужна утилита `systemd-path` в практическом смысле --- трудно предположить. Она отображает разные пути из тех, что описаны в [file-hierarchy(7)](http://www.freedesktop.org/software/systemd/man/file-hierarchy.html), своеобразном обновлённом "аналоге FHS" от разработчиков systemd.

    Наверное, предлагается писать `$(systemd-path search-binaries)` вместо `$PATH`. Или, например, `$(systemd-path user-documents)` вместо разбора XDG-шного `~/.config/user-dirs.dirs` (а вот это уже удобно).

5. `systemd-run` --- выполнение произвольных программ под управлением systemd.

    Эта команда создаёт *временный юнит* в `/run/systemd`, указывает ему в `ExecStart=` переданную в параметрах команду, опционально дописывает некоторые другие свойства и тут же запускает. Юзкейсов потенциально бесконечное количество.

        systemd-run --service-type oneshot /bin/echo "this will be run under systemd"
        systemd-run --nice 20 -p CPUQuota=200% /bin/resource-hungry-daemon

    Конечно, если юнит для демона уже есть, лучше будет запускать именно его, а свойства типа `CPUQuota=` устанавливать через `systemctl set-property`.

    Кстати, systemd имеет пользовательский режим работы. Каждый пользователь, залогиненный хотя бы один раз, получает собственный экземпляр systemd, для управления которым не требуются права root (но и запускается он, естественно, от имени пользователя). Соответственно, команды `systemd-run`, `systemctl` и прочие имеют параметр `--user` с очевидным значением.

        systemd-run --user /bin/echo "this will be run under systemd user instance"
        systemctl --user list-units

    С вспомогательными утилитами на этом всё. Рассмотрим теперь команды, относящихся к анализу конфигурации. Помимо `systemctl status` и `systemctl --failed`, уже упоминавшихся вначале, существуют ещё две.

6. `systemd-delta` --- посмотреть список дополнений и переопределений юнитов.

    Эта команда отображает сводную табличку всех изменений, внесённых в  "системные" юниты (те, что находятся в `/usr/lib`). Возможны варианты: `EXTENDED` (расширен с помощью файла в `.d`-директории), `OVERRIDDEN` (замещён файлом с тем же названием), `MASKED` (симлинк на `/dev/null`), `REDIRECTED` (симлинк на что-то другое) или `EQUIVALENT` (симлинк на то же самое).

    Есть также параметры `--type` (фильтр по вышеописанным вариантам) и `--diff` (показывать дифф между файлами для `OVERRIDDEN`-записей).

7. `systemd-analyze` --- разного рода статистика.

    - `time`                  --- *(по умолчанию)* показывает сообщение о времени, затраченном на каждый из этапов запуска системы: прошивка, загрузчик, ядро, initramfs и основная цель (`default.target`)
    - `blame`                 --- выводит список юнитов, запуск которых занял наибольшее время (отсортированный по убыванию этого времени)
    - `critical-chain [ЦЕЛЬ]` --- выводит цепочку юнитов, которую пришлось ждать дольше всего (проблемные юниты подсвечены красным и указано время ожидания их запуска)
    - `plot`                  --- генерирует bootchart-подобную SVG-диаграмму, позволяющую наглядно оценить порядок запуска юнитов и затраченное на каждый из них время
    - `dot [ЮНИТЫ...]`        --- генерирует граф зависимостей между юнитами в формате `dot`
    - `verify`                --- проверяет указанный юнит-файл на корректность

### Средства конфигурирования системы.

Как нетрудно заметить, в systemd очень активно применяется клиент-серверная архитектура с шиной D-Bus в роли универсального транспорта. Практически каждый компонент (за исключением, наверное, `systemd-networkd`) имеет свой собственный шинный интерфейс --- и отдельную ctl-утилиту в качестве адаптера к этому интерфейсу. Три настроечных утилиты, которые мы сейчас рассмотрим, исключением не являются.

К слову, эта клиент-серверная модель часто вызывает недоумение у тех, кто пытается ознакомиться с systemd: "Как, и для управления хостнеймом свой демон?" Так вот, не всё то висит в памяти, что зовётся демоном. Каждый из *этих* демонов запускается только при получении по шине какого-либо запроса и автоматически завершается через некоторое (весьма малое) время после его обработки. Преимущества такого подхода перед "обычным", когда все действия выполняются непосредственно утилитой командной строки, очевидны:

- проще писать альтернативные UI (например, настройка того же хостнейма в "панели управления" DE)
- есть возможность более тонкой настройки привилегий, чем с помощью SUID-бита на утилите
- проще отследить/перехватить появление сообщения на шине, чем вызов бинарника

Здесь мы, соответственно, рассмотрим только ctl-обёртки.

> Кстати, каждая из них имеет параметр `-H`, который позволяет выполнить операцию удалённо, подключившись к указанной машине по SSH.

1. Настройка системных часов, таймзоны и NTP-сервера: `timedatectl`

    Запуск этой утилиты без параметров приводит к отображению "сводки о текущем положении дел". Под положением дел понимается время (локальное, UTC и то, которое хранится в аппаратных часах), активная таймзона, состояние NTP-сервера, состояние DST и флаг, описывающий, что хранится в аппаратных часах (локальное время или UTC).

    ~~~
          Local time: Пн 2014-12-15 11:13:17 MSK
      Universal time: Пн 2014-12-15 08:13:17 UTC
            RTC time: Пн 2014-12-15 08:13:17
          Time zone: Europe/Moscow (MSK, +0300)
        NTP enabled: yes
    NTP synchronized: yes
    RTC in local TZ: no
          DST active: n/a
    ~~~

    Следует отметить, что, начиная с версии 216, `systemd-timedated` управляет только "комплектным" NTP-клиентом (`systemd-timesyncd`). Предполагается, что основные юзкейсы его функциональность покрывает, а если вам всё же её не хватило и ввиду этого вы сознательно установили другой NTP-сервер/клиент, то вы уже знаете, как им управлять.

    Впрочем, на строку `NTP synchronized` описанное ограничение не распространяется: состояние синхронизации времени берётся из ядра и может быть установлено любым NTP-клиентом.

    - `status`              --- *(по умолчанию)* показывает вышеописанную сводку
    - `set-time`            --- устанавливает локальное время (ожидается аргумент в формате `ГГГГ-ММ-ДД ЧЧ:ММ:СС`)
    - `set-timezone`        --- устанавливает таймзону (ожидается аргумент в формате `Europe/Moscow`; список таймзон можно получить подкомандой `list-timezones`)
    - `list-timezones`      --- выводит список допустимых таймзон
    - `set-local-rtc`       --- включает или отключает хранение локального времени в аппаратных часах (`true` --- локальное время, `false` --- UTC)
    - `set-ntp`             --- включает или отключает "комплектный" NTP-клиент `systemd-timesyncd`

2. Настройка имени хоста и описания системы: `hostnamectl`

    Запуск без параметров --- опять же, вывод достаточно информативного статусного сообщения. В него входит имя хоста, несколько описательных полей вроде физического расположения системы,

    UUID системы и текущей загрузки, имя дистрибутива, версия ядра и так далее.

    ~~~
      Static hostname: intelfx-laptop
            Icon name: computer-laptop
              Chassis: laptop
            Deployment: development
              Location: road to nowhere
            Machine ID: 2ec6cf64aaa5446b99b67d87f1557c41
              Boot ID: 07fbc3ae2b3a4e0a91b7e8465ae4774d
      Operating System: Arch Linux
                Kernel: Linux 3.18.0-pf0-intelfx-00204-g2766b40
          Architecture: x86-64
    ~~~

    Поля "Icon name", "Chassis", "Deployment" и "Location" сугубо пассивны: это строки, которые можно установить и узнать по запросу (хранятся они в [`/etc/machine-info`](http://www.freedesktop.org/software/systemd/man/machine-info.html)). "Machine ID" и "Boot ID" --- это, соответственно, UUID системы (хранится в [`/etc/machine-id`](http://www.freedesktop.org/software/systemd/man/machine-id.html)) и UUID текущей загрузки. Наконец, "Operating System" считывается из [`/usr/lib/os-release`](http://www.freedesktop.org/software/systemd/man/os-release.html).

    Два вышеуказанных UUID используются, например, в `systemd-journald`: первый --- при сборе логов с нескольких машин, а по второму можно фильтровать.

    - `status`         --- *(по умолчанию)* показывает вышеописанную сводку
    - `set-hostname`   --- устанавливает имя хоста: `--static` --- основное, которое хранится в [`/etc/hostname`](http://www.freedesktop.org/software/systemd/man/hostname.html), `--transient` --- получаемое по сети, `--pretty` --- подробное и человекочитаемое
    - `set-icon-name`  --- устанавливает поле "Icon name" (допустимы корректные названия пиктограмм согласно [Icon Naming Specification](http://standards.freedesktop.org/icon-naming-spec/icon-naming-spec-latest.html))
    - `set-chassis`    --- устанавливает поле "Chassis" (допустимы значения из фиксированного списка)
    - `set-deployment` --- устанавливает поле "Deployment" (допустимы значения из фиксированного списка)
    - `set-location`   --- устанавливает поле "Location" (допустимы произвольные строки)

3. Настройка локали и раскладки клавиатуры: `localectl`

    При запуске утилиты без параметров мы получаем текущие значения системной локали, взятые из [`/etc/locale.conf`](http://www.freedesktop.org/software/systemd/man/locale.conf.html), а также текущие настройки клавиатуры для подсистемы VT ядра Linux и для X11.

    ~~~
      System Locale: LANG=ru_RU.UTF-8
                      LC_MESSAGES=en_US.UTF-8
          VC Keymap: ruwin_cplk-UTF-8
          X11 Layout: us,ru
        X11 Variant: ,winkeys
        X11 Options: grp:caps_toggle
    ~~~

    Здесь всё довольно очевидно. Отметим только, что установка одной из раскладок (для X11 или консоли) автоматически устанавливает другую. Это поведение можно отключить, указав параметр `--no-convert`.

    - `status`                   --- *(по умолчанию)* показывает вышеописанную сводку
    - `set-locale`               --- устанавливает системную локаль (ожидаются один или несколько аргументов в формате [locale(7)](http://linux.die.net/man/7/locale), т. е. `LANG=ru_RU.UTF-8`)
    - `list-locales`             --- выводит список доступных локалей
    - `set-keymap`               --- устанавливает раскладку клавиатуры для подсистемы VT (т. е. в консоли)
    - `list-keymaps`             --- выводит список доступных раскладок клавиатуры для подсистемы VT
    - `set-x11-keymap`           --- устанавливает раскладку и опции клавиатуры для X11 (ожидается от одного до четырёх параметров в формате `<раскладка> <модель> <варианты> <опции>`)
    - `list-x11-keymap-models`   --- выводит список доступных "моделей" клавиатуры для X11
    - `list-x11-keymap-layouts`  --- выводит список доступных "раскладок" клавиатуры для X11
    - `list-x11-keymap-variants` --- выводит список доступных "вариантов" раскладок клавиатуры для X11 (опционально допускается указание раскладки, для которой нужно вывести список вариантов)
    - `list-x11-keymap-options`  --- выводит список доступных "опций" клавиатуры для X11

    Настройка системной локали производится при помощи записи значений в `/etc/locale.conf`, подсистемы VT --- при помощи записи значений в [`/etc/vconsole.conf`](http://www.freedesktop.org/software/systemd/man/vconsole.conf.html) (т. е. предполагается использование `systemd-vconsole-setup`), а настройка X11 --- при помощи создания файла `/etc/X11/xorg.conf.d/00-keyboard.conf` с нужными настройками. Из этого следует, что после задания настроек с помощью `localectl` требуется перезапустить соответствующие компоненты системы.

4. Первичная настройка системы: `systemd-firstboot`

    Эта утилита, в отличие от трёх предыдущих, не имеет соответствующего настроечного демона и вносит все изменения напрямую. Это связано с тем, что `systemd-firstboot` предназначен для использования при установке ОС (для этого предусмотрен параметр `--root`) или при первом её запуске.

    С помощью этой утилиты можно задать системную локаль, таймзону, имя хоста, UUID системы и пароль суперпользователя, причём одним из нескольких способов:

    - установить в неинтерактивном режиме, передав утилите соответствующий параметр (`--locale`, `--locale-messages`, `--timezone`, `--hostname`, `--machine-id`, `--root-password` или `--root-password-file`)
    - сгенерировать (`--setup-machine-id`)
    - скопировать из основной системы (параметры `--copy-locale`, `--copy-timezone`, `--copy-root-password` или `--copy` как синоним комбинации всех вышеперечисленных)
    - спросить у пользователя (`--prompt-locale`, `--prompt-timezone`, `--prompt-hostname`, `--prompt-root-password` или `--prompt` как синоним комбинации всех вышеперечисленных)

### Утилиты, используемые `systemd` при загрузке системы.

Все эти программы объединяет следующее: они выполняют то, ради чего до systemd во время загрузки использовались различного рода шелл-скрипты. Показательно то, что типов действий не так и много, и после ознакомления с нижеприведённым списком утилит использование вместо них командного интерпретатора общего назначения (т. е. шелла) действительно начинает выглядеть оверкиллом.

Итак,

1. `systemd-tmpfiles` --- выполнение произвольных операций с файлами и директориями

    Конфигурация этого компонента --- набор последовательно считываемых и обрабатываемых `.conf`-файлов в трёх директориях, имеющих друг над другом приоритет по уже известному принципу. Директории таковы: `/usr/lib/tmpfiles.d`, `/run/tmpfiles.d` и `/etc/tmpfiles.d`.

    Сами файлы представляют собой список действий, по одному на строчку. Формат записи действий можно прочесть в [`tmpfiles.d(5)`](http://www.freedesktop.org/software/systemd/man/tmpfiles.d.html), и на нём мы останавливаться не будем.

2. `systemd-modules-load` --- загрузка модулей ядра

    Здесь всё предельно аналогично. Конфигурационные файлы `systemd-modules-load` располагаются в трёх директориях (`/usr/lib/modules-load.d`, `/run/modules-load.d` и `/etc/modules-load.d`) и содержат имена модулей, предназначенных к загрузке --- опять же, по одному на строчку.

    Стоит отметить, что эти директории не имеют ничего общего с [`modprobe.d(5)`](http://linux.die.net/man/5/modprobe.d) и не заменяют их. В `modprobe.d` перечисляются опции по умолчанию и "чёрный список" автозагрузки, а `modules-load.d` --- это список модулей, которые нужно загрузить принудительно.

3. `systemd-sysusers` --- добавление системных пользователей и групп

    Данный компонент используется для создания отсутствующих системных учётных записей и групп, вплоть до регенерации `/etc/passwd`, `/etc/group` и `/etc/shadow` в случае их отсутствия. Основной юзкейс здесь -- это запуск системы с пустым `/etc`, или (в более общем случае) с пустой корневой ФС, когда `/usr` с мастер-образом монтируется из внешнего источника (вполне вероятно, что в read-only), а остальное пересоздаётся при первом запуске. Впрочем, такая автоматизация может быть полезной и в других случаях --- например, для того, чтобы обеспечить обновление системы без ручного слияния списков пользователей и групп (как это иногда приходилось делать, например, в Arch Linux).

    Конфигурируется `systemd-sysusers` аналогично двум вышеописанным компонентам: с помощью `.conf`-файлов в директориях `/usr/lib/sysusers.d`, `/run/sysusers.d` и `/etc/sysusers.d`.

4. `systemd-binfmt` --- регистрация дополнительных форматов исполняемых файлов

    В отдельную утилиту это вынесли, надо полагать, для удобства: функциональность `systemd-binfmt` полностью реализуется с помощью `tmpfiles.d`-директив, по очереди записывающих нужные строчки в псевдофайл `/proc/sys/fs/binfmt_misc/register`. Тем не менее, список binfmt-правил теперь можно записывать в `.conf`-файлы --- в директориях, как нетрудно догадаться, `/usr/lib/binfmt.d`, `/run/binfmt.d` и `/etc/binfmt.d`.

    Используется такая возможность, например, с Wine: правило `:DOSWin:M::MZ::/usr/bin/wine:` заставит ядро запускать MZ-исполняемые файлы (`*.exe`) с помощью Wine. Это правило и приведено в качестве примера в [`binfmt.d(5)`](http://www.freedesktop.org/software/systemd/man/binfmt.d.html).

5. `systemd-vconsole-setup` --- настройка подсистемы VT ядра Linux

    Наконец, последний компонент. Он конфигурируется в [`/etc/vconsole.conf`](http://www.freedesktop.org/software/systemd/man/vconsole.conf.html) и занимается тем, что настраивает при загрузке ядерную консоль Linux: в частности, шрифт (`FONT=`, `FONT_MAP=` и `FONT_UNIMAP=`) и раскладку клавиатуры (`KEYMAP=` и `KEYMAP_TOGGLE=`).

    К слову, команда `localectl set-keymap` изменяет именно два последних параметра.

## Journald

Теперь пришло время посмотреть на `systemd-journald` --- компонент systemd, отвечающий за общесистемное логирование. Сначала, разумеется, стоит определиться с тем, что мы понимаем под этим термином. `journald` отвечает не только и не столько за хранение логов (в виде бинарной БД), сколько за *сбор и обработку* потоков текста из различных источников.

Итак, `journald` --- это то место, куда `systemd` (PID 1) подсоединяет stdout и stderr запускаемых процессов, чтобы не заниматься их обработкой самостоятельно (что попросту снижает надёжность, т. к. у PID 1 появляется лишний повод свалиться). Так, многое проясняет сравнение возможных значений параметра [`DefaultStandardOutput=`](http://www.freedesktop.org/software/systemd/man/systemd-system.conf.html#LogLevel=) в `/etc/systemd/system.conf`, или, что то же самое, директивы [`StandardOutput=`](http://www.freedesktop.org/software/systemd/man/systemd.exec.html#StandardOutput=) в юнит-файлах, описывающих запуск внешних программ, и [настроек `journald`](http://www.freedesktop.org/software/systemd/man/journald.conf.html#Options) в `/etc/systemd/journald.conf`.

### Перенаправления.

Директива `StandardOutput=` в юнит-файле определяет, куда нужно подсоединять стандартный вывод запускаемых в рамках данного юнита процессов. Вариантов не так много, и их объединяет то, что каждый из них реализуется простым перенаправлением, без какой-либо дополнительной обработки потока текста в контексте PID 1.

**Возможные значения директивы `StandardOutput=`**

- `null`               --- отбросить stdout
- `inherit`            --- *(по умолчанию)* подключить stdout к тому же файловому дескриптору, что и stdin (см. [`StandardInput=`](http://www.freedesktop.org/software/systemd/man/systemd.exec.html#StandardInput=) в юнит-файле)
- `tty`                --- подключить stdout к терминалу, указанному директивой [`TTYPath=`](http://www.freedesktop.org/software/systemd/man/systemd.exec.html#TTYPath=) в юнит-файле
- `socket`             --- *(только для сокет-активируемых юнитов)* подключить stdout к сокету
- `journal`            --- направить stdout в `journald`
- `syslog`             --- направить stdout в `journald` и включить для данного юнита перенаправление в syslog (см. [`ForwardToSyslog=`](http://www.freedesktop.org/software/systemd/man/journald.conf.html#ForwardToSyslog=) в `journald.conf`)
- `kmsg`               --- направить stdout в `journald` и включить для данного юнита перенаправление в буфер сообщений ядра (см. [`ForwardToKMsg=`](http://www.freedesktop.org/software/systemd/man/journald.conf.html#ForwardToKMsg=) в `journald.conf`)
- `journal+console`    --- то же `journal`, плюс перенаправление в `/dev/console`(см. [`ForwardToConsole=`](http://www.freedesktop.org/software/systemd/man/journald.conf.html#ForwardToConsole=) в `journald.conf`)
- `syslog+console`     --- то же `syslog`, плюс перенаправление в `/dev/console`(см. [`ForwardToConsole=`](http://www.freedesktop.org/software/systemd/man/journald.conf.html#ForwardToConsole=) в `journald.conf`)
- `kmsg+console`       --- то же `kmsg`, плюс перенаправление в `/dev/console`(см. [`ForwardToConsole=`](http://www.freedesktop.org/software/systemd/man/journald.conf.html#ForwardToConsole=) в `journald.conf`)

*(Также существует директива [`StandardError=`](http://www.freedesktop.org/software/systemd/man/systemd.exec.html#StandardError=), принимающая аналогичный набор значений.)*

Можно видеть, что перенаправление в `/dev/null`, tty или сокет выполняется "напрямую", без использования промежуточного звена в виде демона `journald`.

А вот перенаправление в syslog, kmsg или `/dev/console` (альтернативный путь можно указать директивой [`TTYPath=`](http://www.freedesktop.org/software/systemd/man/journald.conf.html#TTYPath=) в `journald.conf`) выполняется только через `journald`, что и неудивительно: в каждом из этих случаев текстовый поток необходимо дополнительно обрабатывать. Чем, собственно, демон и занимается.

### Что происходит в системе?

Итак, мы выяснили, что `journald` --- это, в первую очередь, сборщик логов, а не писатель в бинарные файлы. Теперь разберёмся с тем,

1. Откуда он может получать информацию.

    - **Во-первых**, это нативный API для логгирования: [`sd-journal.h`](http://www.freedesktop.org/software/systemd/man/sd-journal.html) (в частности, [`sd_journal_print(3)`](http://www.freedesktop.org/software/systemd/man/sd_journal_print.html)). Он отличается, например, от того же [syslog(3)](http://linux.die.net/man/3/syslog) тем, что позволяет присоединять к сообщениям произвольные метаданные в форме `KEY=VALUE` (об этом позже).

    - **Во-вторых**, это, собственно, [syslog(3)](http://linux.die.net/man/3/syslog). `journald` открывает и слушает сокет `/dev/log` (являясь в некотором смысле альтернативой [syslogd(8)](http://linux.die.net/man/8/syslogd) для Linux-систем).

    - **В-третьих**, это буфер сообщений ядра, `/proc/kmsg` (тот, который отображает команда [`dmesg(1)`](http://linux.die.net/man/1/dmesg)).

    - **В-четвёртых**, это stdout и stderr процессов, подконтрольных systemd (мы их как раз рассмотрели разделом выше).

2. Куда он её способен впоследствии передавать/сохранять.

    `journald` - демон-сборщик логов и опционально писатель, который отвечает за сбор сообщений ядра, initrd, и также STDOUT & STDERR от различных процессов. Хранением логов может заниматься как сам journal, так и опционально syslog c помощью форвардинга от journal.

    Вопреки  распространенному мифу, что логи journal могут читаться только  journalctl и это может стать большой проблемой, они также  могут  читаться утилитой strings. Пример: `strings  /var/log/journal/name_of_log_file | grep -i message`

    Где же хранятся логи? Для хранения используется директория `/var/log/journal`, для буфера используется `/run/log/journal`. Размер хранилища, ротация и другие параметры кофигурации настраиваются в `/etc/systemd/journald.conf`.

    - `ForwardToSyslog` --- перенаправление в `syslog`
    - `Storage`         --- где именно будут хранится логи (или не храниться вовсе в случае `Storage=none`;
        - `volatile` - только в `RAM`,
        - `persistent` - на диске,
        - `auto` - аналогично `persistent` но без директории `/var/log/journal/`)
    - `SystemMaxUse=`, `SystemKeepFree=`, `SystemMaxFileSize=`, `RuntimeMaxUse=`, `RuntimeKeepFree=`, `RuntimeMaxFileSize=` --- отвечают за различные лимиты: максимальный размер файла, максимальный размер свободного места, максимальный размер логов `journal` и т.д
    - ...
    - `Compress`       --- поддержка xz-комрессии
    - `MaxFileSec`     --- максимальный час записи логов в один файл

    Более детально можно посмотреть в  `man journald.conf`.

3. Просмотром логов и их фильтрацией занимается команда `journalctl`.

**Опции `journalctl:`**

- -f           --- просмотр логов в реальном времени(tail -f)
- -b           --- просмотр логов с момента загрузки
- -e           --- сразу перейти в конец вывода
- -a           --- показать вывод посностью, включая непечатные символы
- -o           --- вывод логов в различных форматах и структурах
- -m           --- вывод логов со всех доступных журналов
- -k           --- только сообщения ядра
- --disk-usage --- показать сколько использовано места на диске
- --verify     --- проверка логов
- --flush      --- принудительный перенос логов на диск, если его использование разрешено
- -M           --- указание контейнера

**Также доступны фильтры:**

- -u, --unit       --- по юниту (-u avahi-daemon)
- -p, --priority   --- по приоритету
  - `emerg`   (0),
  - `alert`   (1),
  - `crit`    (2),
  - `err`     (3),
  - `warning` (4),
  - `notice`  (5),
  - `info`    (6),
  - `debug`   (7).
- --since, --until --- по времени (--since "2015-01-12 23:00:00" --until "2015-01-12 23:30:00")

**В качестве аргументов journalctl также можно указывать блочные устройства и полные пути к бинарным файлам:**

    journalctl /usr/bin/mount
    journalctl /dev/sdb

4. Безопасность и шифрование логов.

Для безопастности можно активировать шифрование логов  (`Seal=yes` в `/etc/system/journald.conf`)

Для начала генерируем ключи:

    journalctl --setup-keys

И мы получаем великий и страшный `qr-code`. Это зделано для того, чтобы не хранить ключ на машине, на которой собственно хранятся логи. Можно также получить ключ в текстовом виде:

    journalctl --setup-keys --force | cat

`/var/log/journal`, `/run/log/journal` --- место хранения логов

## Playlist на YouTube

https://www.youtube.com/playlist?list=PLqqACcIaake6YIicCFFadRAk-9N5Wamd2

## Ссылки.

- [Suse Wiki:systemd](https://ru.opensuse.org/SDB:Systemd)
- [Systemd за пять минут](https://habrahabr.ru/company/southbridge/blog/255845/)
- [Шпаргалка systemd](http://mppks.ru/ubuntu/shpargalka-systemd/)
- [Шпаргалка по работе с journalctl](https://sysadmin.pm/journald-journalctl/)
- [Alt Wiki:Journald](https://www.altlinux.org/Journald)
- [Alt Wiki:Systemd](https://www.altlinux.org/Systemd)
- [Alt Wiki:Улучшаем Systemd](https://www.altlinux.org/%D0%A3%D1%87%D0%B0%D1%81%D1%82%D0%BD%D0%B8%D0%BA:HihinRuslan/Systemd)
- [How can I send a message to the systemd journal from the command line](https://serverfault.com/questions/573946/how-can-i-send-a-message-to-the-systemd-journal-from-the-command-line)

**Источник**: https://github.com/paulcarroty/systemd-In-Action

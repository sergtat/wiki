# SSHFS. Удобный доступ к файлам на удаленных хостах.
Достаточно много разработчиков работают с файлами на удаленных хостах. На локальной машине запускается IDE, отладчик, все необходимое, а сами файлы находятся на сервере, где они регулярно бакапятся, автобилдятся, тестируются и так далее. Очень удобный рабочий вариант. Да я сам его использую.

Единственная проблема, доставляющая неудобство — файлы все же находятся на другом компе, и доступ к ним не такой простой и прозрачный как к «своим».

**Как сделать такой доступ максимально удобным? Чтобы он запускался автоматом когда надо, а самое главное — чтобы не запускался, когда не надо?**

Из всех вариантов удаленного доступа к файлам: SSHFS, NFS и виндошара — SMB (не к ночи будь помянут), я выбрал SSHFS по следующим причинам:

- Максимальная простота настройки
- Работает практически везде, не требует установки на сервер хитрых компонент
- Максимальная безопасность: клиента, сервера и передаваемых данных.

Установка на Ubuntu максимально проста:

```bash
$ sudo apt-get install sshfs
```

При этом автоматически установится в качестве зависимостей fuse-utils и libfuse2.

Так же должна создаться группа fuse и в modconf.d пропишется загрузка модуля fuse — впрочем это зависит от вашего дистрибутива, возможно это придется проверить и подправить руками.

Для пользователей Windows есть самурайская разработка [Dokan SSHFS](http://dokan-dev.net/en/download/). Качаем Dokan lib, потом dokan sshfs. Эта штука работает, но говорю сразу — я с ней практически не работал, может при длительной эксплуатации и вылезут какие-то проблемы.

Теперь все это можно легко замаунтить консольным вызовом:

```bash
$ sshfs username@server.ru:/home/user mount-point/
```

Но это не самый удобный вариант использования — надо каждый раз в консоли маунтить папку, конечно, можно все это прописать в `/ets/fstab`, но у нас есть вариант получше — [Automount FUSE](http://afuse.sourceforge.net/). Ставить опять можно из репозитариев:

```bash
$ sudo apt-get install afuse
```

После чего достаточно его запустить с нужными парамтерами:

```bash
afuse -o mount_template="sshfs %r:/ %m" -o unmount_template="fusermount -u -z %m" ~/sshfs/
```

После чего все обращения к файлам и папкам в папке `~/sshfs/` будут вызывать монтирование соответствующей папки в `~/sshfs/`. После чего обращение пойдет дальше на удаленный хост. Самое главное для нас — все происходит абсолютно прозрачно при первом обращении к нужной папке **из любой программы**.

Например: ls `~/sshfs/tmpvar@foobarhost.com` вначале малость потормозит, потом покажет содержимое корневой папки `/` сервера `foobarhost.com`. Конечно, не всегда удобно писать полный адрес и параметры доступа к серверу `tmpvar@foobarhost.com:22`, поэтому мы их перенесем в настройки доступа ssh.

```bash
cat ~/.ssh/config 
Host file-storage
	Hostname	filestorage.server.ru
	Port		2222           # на сервере может быть использован нестандартный порт
	HostKeyAlias	fs 
	User		admin
```

Теперь мы можем обращаться к нашему серверу по короткому имени fs как в ssh, так и в sshfs:

```bash
> ssh fs # заходим на сервер — никаких лишних настроек не надо
> ls ~/sshfs/fs # смотрим корневую папку сервера.
```

Если вы монтите папку первый раз, то у вас появится окошко ввода пароля для доступа к указанному серверу. После того как соединение установлено, окно больше не будет вас докучать. Как вы уже поняли — можно легко сказать окну не вылезать — сделав авторизацию на сервер по ключу.

**Итак, что же мы получили?**

А получили мы классную вещь — прозрачное SSHFS-монтирование папок по требованию. Это обозначает, что:

- монтирование осуществляется **автоматически когда нужно**. Например, утром я включаю свой ноут и открываю Eclipse c текущим проектом. Как только он запустится, он тут же открывает старые файлы с сервера, при этом монтится папка и происходит вся скрытая механика. Но меня, как пользователя, это уже не интересует — я запускаю прогу и работаю в ней.
- но есть вещи гораздо интереснее: **монтирование не запускается когда не надо!** Например, вы сидите в интернет-кафе или на даче на gprs-модеме. Вот скажите, вам сильно надо чтобы при запуске ноута подключались все папки с рабочего сервера? В итоге загрузка длилась полчаса и выдавала гору ошибок? Вот это и есть главное преимущество перед прописыванием настроек в `/etc/fstab` — когда не надо, система вам не мешает. :)

Но человек быстро привыкает ко всему хорошему. Я перся с этой системы ровно 2 недели — а потом начал банально забывать запускать afuse :). В итоге пришлось сделать небольшой скриптец, который это будет делать за меня:

```bash
$  cat ~/bin/afuse.sh 
#!/bin/sh

if [ ! -z  `ls -d /tmp/afuse-* 2>/dev/null`  ]; then 
  echo 'Afuse is already running'; 
else
  /usr/bin/afuse -o mount_template="sshfs %r:/ %m" -o unmount_template="fusermount -u -z %m"   ~/sshfs/
fi
```

и добавил его в автозапуск в GNOME.

Вот теперь система стала идеальной :)

**Источник**: https://habrahabr.ru/

## Комментарии:
Если надо редактировать файлы в Windows и дублировать изменения на unix, правильней будет другой подход.

Есть такая программа WinSCP — морда для putty, похожая на TotalComander, поддерживающая сессии от putty. У неё есть режим зеркалирования удалённой папки. На стороне windows наблюдение за измененями в файловой системе делается встроенными малозатратными механизмами (хуки вешаются), поэтому изменения подхватываются быстро. Файлы, которые дублировать не надо, можно отфильтровать — например, служебные файлы от subversion, бэкапные копии, временные файлы.

Плюсы — при падении сети файлы никуда не исчезают на обоих концах, достаточно сделать реконнект, часто без повторной синхронизации. Не надо делать дополнительных настроек на обеих машинах. При разработке совершенно прозрачно всё копируется. Естественно, копирование одностороннее, то есть править руками удалённую директорию не стоит — исправления будут убиты.

Срабатывание практически мгновенно. Windows, в отличии от Unix, имеет механизм, позволяющий перехватить операции с файлами или узнать об этих операциях — например, так работают антивирусные мониторы. В Linux надо периодически (например раз в минуту, где-то это называется poll) опрашивать директорию с файлом и смотреть, не изменился ли он, в Windows это не нужно, операционная система сама сообщает приложению в момент изменения. Поэтому и возможно мгновенно вызывать обновление на удалённом сервере.

---
Вы немного отстали: в линухе довольно давно есть механизм [inotify](http://ru.wikipedia.org/wiki/Inotify).

```bash
#!/bin/sh
# A slightly complex but actually useful example
inotifywait -mrq --timefmt '%d/%m/%y %H:%M' --format '%T %f' \
 -e close_write /home/billy | while read date time file; do
    rsync /home/billy/${file} rsync://billy@example.com/backup/${file} && \
    echo "At ${time} on ${date}, file ${file} was backed up via rsync"
done
```
> Скажем прямо, Ваш пример как раз и есть глючный. Например представьте, что в течении минуты будут изменены файлы в сотне разных директорий (что, к примеру, бывает при SVN commit). Что произойдёт? Можно сразу сказать — беда будет :) для обеих машин. Значит надо предусмотреть опции, надо предусмотреть методику их хранения и изменения, надо вести логи копирования… Надо подумать как не закрывать соединение с сервером. Много чего нужно для комфортной работы. Поэтому и возник у меня вопрос — есть ли готовый софт с функциональностью WinSCP? Кстати, rsync на виндусовых машинахимеет кучу проблем, начиная с поддержки ключей от putty и кончая зависаниями, так что и он не сильно поможет.

Во-первых это был пример, о чём там есть соотв. disclaimer.

Во-вторых, давайте не будем придумывать себе проблемы заранее. Я пока не вижу причины, по которой svn заливающий один за другим сотню файлов проблем не вызывает, а rsync параллельно с ним заливающий эти же файлы на другую машину, сразу всё положит, причём на обоих машинах.

В-третьих, если Вы хотите «всё продумать», «постоянное соединение» — продумайте, организуйте соединение, и немного скорректируйте приведённый выше пример для своих условий. Получится простое, понятное и управляемое решение с требуемым уровнем надёжности.

> По второму пункту: принципиальный недостаток — на каждое изменение запуск rsync — отсюда и проблемы с производительностью. Установка соединения ssh часто бывает медленной, так что сам процесс соединения может быть самой долгой операцией. Идеалом было бы установка соединения и чтение потока событий, вот такую программу было бы здорово найти.

> Я смотрел в другую сторону насчёт использования inotify — файловые системы пользовательского уровня. Вроде есть такие, google на «inotify mirror» выдаёт много вариантов — но некоторые я посмотрел — в анонсах inotify есть, в исходниках нет, а тестировать некогда.

> Нашёл даже inotify.aiken.cz/?section=incron&page=about&lang=en — «This program is an „inotify cron“ system. It consists of a daemon and a table manipulator. You can use it a similar way as the regular cron. The difference is that the inotify cron handles filesystem events rather than time periods.», она Ваш пример хорошо перекрывает, но это не совсем то что хотелось бы. Но для организации передачи небольших файлов через hot-directory (так это обычно называется в похожих программах) хорошо подходит.

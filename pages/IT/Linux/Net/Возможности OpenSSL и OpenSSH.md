# Возможности OpenSSL и OpenSSH.
## OpenSSH

OpenSSH, пришедший на смену дырявому Telnet, до сих пор занимает первое место среди систем удаленного управления благодаря безопасности и простоте в использовании. Разобраться в нем способны все, даже самые хромированные чайники, однако подавляющее большинство пользователей задействует минимум его возможностей. Опустим рассказы о ключах, пробросах портов, проксировании и других полезных, но всем известных приемах и рассмотрим на самом деле интересные и не слишком распространенные способы использования этого инструмента.

![Используем OpenSSL для подключения к Gmail](/images/Linux/Security/openssl_gmail.jpg)

Используем OpenSSL для подключения к Gmail

> INFO

> С полным списком команд OpenSSL можно ознакомиться с помощью следующих параметров: list-standart-commands, list-message-digest-commands, list-cipher-commands.

Итак, трюк номер один — множественные подключения. OpenSSH способен обслуживать множество одновременных соединений с одной и той же машиной. Обычно пользователи просто запускают команду и ждут ее завершения, чтобы запустить следующую. К счастью, эту проблему легко обойти путем разделения одного соединения на множество сессий. Просто добавь в конфиг ssh (~/.ssh/config) следующие строки:

```
ControlMaster auto
ControlPath ~/.ssh/mux_%h_%p_%r
```
Ты сможешь создать столько соединений с одним и тем же сервером, сколько посчитаешь нужным, причем время на повторную аутентификацию тратить будет не нужно.

![Шифруем файлы с помощью OpenSSL](/images/Linux/Security/openssl_encode.jpg)

Шифруем файлы с помощью OpenSSL

Трюк номер два — проксирование соединений. Допустим, ты не можешь создать соединение с SSH-сервером напрямую, но можешь использовать для этого другой хост, к которому ты тоже имеешь SSH-доступ. Добавь в свой конфиг следующие строки:

```
ForwardAgent yes
Host host
HostName host.com
ProxyCommand ssh proxy-host.com \
netcat -q 600 %h %p
```
Команда ssh host создаст соединение с сервером host.com через сервер proxy-host.com.

Трюк номер три — выход за пределы HTTP-изоляции. Многие организации не просто режут неугодный им трафик, но и принуждают пользователей выходить в Сеть только с использованием HTTP-протокола. Такую несправедливость легко обойти с помощью сorkscrew (www.agroman.net/corkscrew/), который умеет туннелировать SSH-трафик через HTTP. Просто установи его на свою машину и добавь в конфиг следующие строки (где proxy.com и 80 — это адрес внешнего HTTP-прокси и его порт):

```
Host *
ProxyCommand corkscrew proxy.com 80 %h %p
```
Теперь все соединения пойдут через указанный HTTP-прокси.

Трюк номер четыре — тест пропускной способности сети. Чтобы протестировать скорость соединения, необязательно устанавливать специализированное ПО, достаточно утилиты pv и старого доброго SSH:

```
$ sudo apt-get install pv
$ yes | pv | ssh host.com "cat > /dev/null"
```
![Тестируем скорость соединения с помощью SSH и pv](/images/Linux/Security/ssh_pv.jpg)

Тестируем скорость соединения с помощью SSH и pv

Трюк номер пять — удаленный анализ сетевого трафика. Почти в любой UNIX-системе есть сетевой сниффер tcpdump, однако читать его логи довольно утомительно. Возможности OpenSSH помогут упростить анализ трафика:

```
$ ssh root@host.com tcpdump -w – 'port !22' \
| wireshark -k -i -
```
Теперь весь трафик, проходящий через host.com, будет виден в графическом окне wireshark на твоей машине.

Трюк номер шесть — передача файлов на низкой скорости. Иногда бывает необходимо передать большое количество файлов на удаленную машину, но сделать это так, чтобы процесс не мешал работе с сетью. В этом случае можно воспользоваться инструментом cstream:

```
$ sudo apt-get install cstream
$ tar -cj /backup | cstream -t 512k | \
ssh host 'tar -xj -C /backup'
```
Трюк номер семь — всегда открытая SSH-сессия. Пользователям ноутбуков, чье соединение с сетью может быть не постоянным, приходится каждый раз заново запускать SSH-клиент в момент, когда сеть появляется, и убивать его при потере соединения. Избежать этого можно с помощью инструмента autossh, который будет поддерживать иллюзию постоянного соединения с сервером, восстанавливая связь, когда сеть окажется доступной:

```
$ sudo apt-get install autossh
$ autossh -M50000 -t server.example.com \
'screen -raAd mysession'
```

~[Делаем бенчмарк SSL-сервера Gmail](/images/Linux/Security/openssl_s_time.jpg)

Делаем бенчмарк SSL-сервера Gmail

Трюк номер восемь — запуск команды на нескольких серверах одновременно. Комментарии излишни:

```
$ echo "uptime" | pee "ssh host1" "ssh host2" \
"ssh host3"
```
Трюк номер девять — удаленное сравнение файлов. Часто требуется сравнить локальную и удаленную версию какого-либо конфига, однако копировать файлы туда-сюда неудобно и долго. В этом случае можно воспользоваться следующей командой:

```
$ ssh user@host cat /путь/к/удаленному/файлу | \
diff /путь/к/локальному/файлу -
```
То же самое можно проделать для двух файлов, находящихся на разных серверах:

```
$ diff <(ssh host1 cat /etc/apt/sources.list) \
<(ssh host2 cat /etc/apt/sources.list)
```
> cpu0: RNG AES

> Результаты бенчмарка криптографических средств, встроенных в CPU платформы VIA Eden (процессорные инструкции для работы с алгоритмом блочного симметричного шифрования AES):

```
% openssl speed -elapsed -evp aes-256-cbc
type 16 bytes 64 bytes256 bytes   1024 bytes   8192 bytes
aes-256-cbc  21780.33k79591.78k   198578.08k   317102.05k   383371.05k
```
Трюк номер 10 — одновременный просмотр логов с нескольких машин. С помощью multitail и SSH можно запросто просматривать логи с двух серверов одновременно:

```
$ sudo apt-get install multitail
$ multitail -l 'ssh host1 "tail -f \
/var/log/apache2/error.log"' -l 'ssh host2 \
"tail -f /var/log/apache2/error.log"'
```
Трюк номер 11 — копирование файлов с одной удаленной машины на другую через локальную. В случае если две удаленные машины не могут установить связь друг с другом, файлы между ними можно передавать, используя свой комп в качестве промежуточного звена:

```
$ ssh root@host1 "cd /каталог && tar -cf – ." |\
ssh root@host2 "cd /каталог && tar -xf -"
```
Трюк номер 12 — копирование вывода удаленной команды в буфер обмена. Часто требуется скопировать вывод удаленной команды в буфер обмена, чтобы вставить его в письмо, сообщение форума и т. д. Проще всего это сделать с помощью утилиты xclip:

```
$ ssh user@host cat /файл.txt | xclip
```
Трюк номер 13 — синхронизация времени средствами SSH. В случае, если машина не имеет доступа к NTP-серверу или на ней не установлен NTP-клиент, синхронизировать время между машинами можно так:

```
# date --set="$(ssh user@server date)"
```
Трюк номер 14 — установка пакетов удаленной машины на локальную. Нередко требуется синхронизировать две машины так, чтобы они имели одинаковый набор установленных пакетов. Стандартными методами сделать это сложно, но с помощью SSH проще простого:

```
# ssh remotehost 'dpkg --get-selections' | \
dpkg --set-selections && dselect install
```
Трюк номер 15 — снимок удаленного экрана. Можно очень легко получить изображение X-сервера с удаленной машины, воспользовавшись стандартным графическим пакетом ImageMagick:

```
# ssh user@host "DISPLAY=:0.0 import -window \
root -format png -" | display -format png -
```
Чтобы сохранить его в файле, последнюю команду следует заменить на `> file.png`

Трюк номер 16 — ускорение передачи данных. Если машины, с которыми установлено соединение, находятся внутри заведомо безопасной сети (например, офис или дом), передачу данных средствами SSH можно несколько ускорить, если использовать менее стойкий алгоритм шифрования. Для этого добавь в конфигурационный файл следующие строки:

```
Host host.com
Ciphers arcfour256
MACs umac-64@openssh.com
```
Трюк номер 17 — вывод звука с удаленной машины на локальную. Вместе с картинкой рабочего стола удаленной машины иногда хочется получить и звук. Это делается с помощью банального dd:

```
$ dd if=/dev/dsp | ssh -c arcfour -C \
user@host dd of=/dev/dsp
```
Трюк номер 18 — запуск локального скрипта на удаленной машине. Нередко требуется запустить скрипт на удаленной машине, однако копировать его туда совсем необязательно, достаточно выполнить следующую простую команду:

```
$ ssh -T user@host < script.sh
```

## OpenSSL

OpenSSL представляет собой систему защиты и сертификации данных, которая была разработана в ответ на создание протокола безопасных сокетов SSL компанией Netscape. Вопреки расхожему мнению, OpenSSL вовсе не является инструментом для реализации SSL-протокола и может выполнять множество самых разнообразных функций, в том числе управлять ключами и сертификатами, рассчитывать хеши и т. д. Вот лишь неполный список возможностей этого криптографического комбайна:

- создание ключей RSA и DSA и управление ими (команды rsa, dsa, dsaparam);
- создание сертификатов формата x509, формирование запросов на сертификацию, восстановление (команды x509, req, verify, ca, crl, pks12, pks7);
- симметричное и асимметричное шифрование данных (команды enc, rsautl);
- расчет хешей (команда dgst);
- работа с S/MIME (команда s/mime).

Также OpenSSL может быть использован для проверки SSL-серверов и клиентов с помощью специальных команд sclient/sserver и для тестирования скорости работы различных алгоритмов (команда speed).

Мы не раз писали о работе с пакетом OpenSSL, поэтому не будем рассматривать стандартные примеры его использования вроде создания хешей и сертификатов, а сразу перейдем к более серьезным трюкам.

![Тестируем скорость алгоритмов с помощью команды speed](/images/Linux/Security/openssl_speed.jpg)

Тестируем скорость алгоритмов с помощью команды speed

### Время — деньги

Одна из интересных особенностей OpenSSL заключается в том, что он может провести бенчмарк используемых алгоритмов и скорости установления SSL-соединения. Для этого предназначена стандартная команда s_time. Чтобы оценить скорость установки SSL-соединения, нужно применить ее к команде openssl:

```
$ openssl s_time -connect gmail.com:443 \
-www /test.html -new
103 connections in 0.75s; 137.33 connections/user sec, bytes read 42436
103 connections in 31 real seconds, 412 bytes read per connection
```
То же самое можно проделать с помощью наиболее стойких алгоритмов:

```
$ openssl s_time -ssl3 -cipher HIGH \
-connect gmail.com:443 -www / -new
99 connections in 0.73s; 135.62 connections/user sec, bytes read 40788
99 connections in 31 real seconds, 412 bytes read per connection
```
Эти две команды позволяют определить максимальную пропускную способность SSL-сервера. Но еще более интересный способ заключается в тестировании всех поддерживаемых алгоритмов. Для этого нам придется прибегнуть к скриптингу:

```
IFS=":"
for c in $(openssl ciphers -ssl3 RSA); do
  echo $c
  openssl s_time -connect host:443 -www / -new \
  -time 10 -cipher $c 2>&1 | grep bytes
  echo
done
```
Такая команда позволяет измерить скорость установки SSL-соединения с помощью различных алгоритмов шифрования, что можно использовать, например, для тюнинга SSL-сервера. Если же SSL-сервера как такового еще нет, его легко эмулировать с помощью самого OpenSSL. На серверной машине запускаем OpenSSL-сервер:

```
$ openssl s_server -cert mycert.pem -www
```
На клиентской выполняем следующую команду:

```
$ openssl s_time -connect myhost:4433 \
-www / -new -ssl3
```
### Клиентская сторона

Еще одна интересная команда OpenSSL — это s_client, которая позволяет коннектиться к удаленным SSL-серверам для их тестирования. Чаще всего я использую эту команду, чтобы проверить дату выдачи сертификата. Для этого следует просто подключиться к удаленному SSL-серверу, дождаться, пока на экране появится информация о сертификате, а затем прогнать его через всё тот же openssl, чтобы вычленить даты. При использовании одной команды всё это выглядит так:

```
$ echo | openssl s_client -connect \
www.google.com:443 2>/dev/null | \
openssl x509 -dates -noout
notBefore=Oct 26 00:00:00 2011 GMT
notAfter=Sep 30 23:59:59 2013 GMT
```
![Вычленяем нужную информацию из сертификата x509](/images/Linux/Security/openssl_x509.jpg)

Вычленяем нужную информацию из сертификата x509

Команду `s_client` можно также применять для тестирования сервера на уязвимость, заключающуюся в использовании нестойких алгоритмов шифрования:

```
$ openssl s_client -connect www.google.com:443 \
    -cipher LOW
CONNECTED(00000003)
140513251690152:error:14077410:SSL routines:SSL23_GET_SERVER_HELLO:sslv3 alert handshake failure:s23_clnt.c:658:
```
Сервер, не поддерживающий нестойкие алгоритмы шифрования, просто откажется устанавливать соединение, как это и произошло в случае с сервером Google. Команда `s_client` также довольно удобна для отладки различных протоколов (в этом случае она выступает в виде SSL’ного Telnet). Например:

```
$ openssl s_client -starttls smtp -crlf \
    -connect smtp.gmail.com:25
```
### Шифрование

О шифровании с помощью OpenSSL не писал только ленивый, поэтому мы остановимся не на самих принципах шифрования, а на том, как его можно использовать для вспомогательных задач. Утилита командной строки openssl удобна тем, что она, как и все остальные команды UNIX, может принимать данные на вход и имеет для них стандартный выход. В результате с помощью одной простой команды можно обеспечить, например, защищенную передачу файла по сети:

```
отправляющий$ cat /etc/passwd | openssl \
aes-256-cbc -a -e -pass pass:пароль | \
netcat -l -p 8080
принимающий$ netcat хост:8080 | openssl \
aes-256-cbc -a -d -pass pass:пароль > passwd
```
Можно также применять и различные скрипты, чтобы автоматизировать шифрование множества файлов (пароль шифрования в /tmp/passwd):

```
$ for f in * ; do [ -f $f ] && \
openssl enc -aes-256-cbc -salt -in $f \
    -out $f.enc -pass file:/tmp/passwd ; done
```
Для расшифровки отдельно взятых файлов используем следующую команду:

```
    $ openssl enc -d -aes-256-cbc -salt \
    -in файл.enc -out filename \
    -pass file:/path/to/passwd
```
Для шифрования целого каталога проще, конечно, воспользоваться такой конструкцией:

```
$ tar c каталог | openssl enc -aes-256-cbc -e \
> secret.tar.enc
```   
OpenSSL удобно использовать для генерирования паролей:

```
$ openssl rand 8 -base64
O0Hqtv9l0sY=
```
А сгенерировать хеш для записи в /etc/passwd можно так:

```
# openssl passwd -1 my-secret-pass
$1$WA7AVhQL$y9VaGwseiKRLSGoJg21TP0
```
Кстати, кодирование в base64 может пригодиться для отправки файлов, если двоичная передача данных не поддерживается:

```
$ tar -c каталог | gzip -9 | openssl enc \
-base64 > text-message.txt
```
Возможность генерирования случайных данных можно использовать для создания фиктивных MAC-адресов:

```
$ openssl rand -hex 6 | \
sed 's/\(..\)/\1:/g; s/.$//'
f2:9e:56:fd:5a:93
```
## Выводы

Когда речь заходит о таких развитых, проверенных временем и широко применяемых инструментах, как OpenSSL и OpenSSH, юниксоиды незамедлительно начинают приводить десятки примеров их использования в повседневной жизни. Иногда эти примеры кажутся простыми и обыденными, но иногда просто поражаешься находчивости разработчиков и пользователей этих программ.

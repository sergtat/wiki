# OpenSSL. Возможности OpenSSL.

**OpenSSL** представляет собой систему защиты и сертификации данных, которая была разработана в ответ на создание протокола безопасных сокетов SSL компанией Netscape. Вопреки расхожему мнению, OpenSSL вовсе не является инструментом для реализации SSL-протокола и может выполнять множество самых разнообразных функций, в том числе управлять ключами и сертификатами, рассчитывать хеши и т. д. Вот лишь неполный список возможностей этого криптографического комбайна:

- создание ключей RSA и DSA и управление ими (команды rsa, dsa, dsaparam);
- создание сертификатов формата x509, формирование запросов на сертификацию, восстановление (команды x509, req, verify, ca, crl, pks12, pks7);
- симметричное и асимметричное шифрование данных (команды enc, rsautl);
- расчет хешей (команда dgst);
- работа с S/MIME (команда s/mime).

Также OpenSSL может быть использован для проверки SSL-серверов и клиентов с помощью специальных команд sclient/sserver и для тестирования скорости работы различных алгоритмов (команда speed).

Мы не раз писали о работе с пакетом OpenSSL, поэтому не будем рассматривать стандартные примеры его использования вроде создания хешей и сертификатов, а сразу перейдем к более серьезным трюкам.

![Используем OpenSSL для подключения к Gmail](/images/Linux/Security/openssl_gmail.jpg)  
_Используем OpenSSL для подключения к Gmail_

> **INFO**

> С полным списком команд OpenSSL можно ознакомиться с помощью следующих параметров: list-standart-commands, list-message-digest-commands, list-cipher-commands.

![Тестируем скорость алгоритмов с помощью команды speed](/images/Linux/Security/openssl_speed.jpg)  
Тестируем скорость алгоритмов с помощью команды speed

### Время — деньги

![Делаем бенчмарк SSL-сервера Gmail](/images/Linux/Security/openssl_s_time.jpg)  
Делаем бенчмарк SSL-сервера Gmail

> cpu0: RNG AES

> Результаты бенчмарка криптографических средств, встроенных в CPU платформы VIA Eden (процессорные инструкции для работы с алгоритмом блочного симметричного шифрования AES):

```
% openssl speed -elapsed -evp aes-256-cbc
type 16 bytes 64 bytes256 bytes   1024 bytes   8192 bytes
aes-256-cbc  21780.33k79591.78k   198578.08k   317102.05k   383371.05k
```
Одна из интересных особенностей OpenSSL заключается в том, что он может провести бенчмарк используемых алгоритмов и скорости установления SSL-соединения. Для этого предназначена стандартная команда s_time. Чтобы оценить скорость установки SSL-соединения, нужно применить ее к команде openssl:

```
$ openssl s_time -connect gmail.com:443 \
-www /test.html -new
103 connections in 0.75s; 137.33 connections/user sec, bytes read 42436
103 connections in 31 real seconds, 412 bytes read per connection
```
То же самое можно проделать с помощью наиболее стойких алгоритмов:

```
$ openssl s_time -ssl3 -cipher HIGH \
-connect gmail.com:443 -www / -new
99 connections in 0.73s; 135.62 connections/user sec, bytes read 40788
99 connections in 31 real seconds, 412 bytes read per connection
```

Эти две команды позволяют определить максимальную пропускную способность SSL-сервера. Но еще более интересный способ заключается в тестировании всех поддерживаемых алгоритмов. Для этого нам придется прибегнуть к скриптингу:

```
IFS=":"
for c in $(openssl ciphers -ssl3 RSA); do
  echo $c
  openssl s_time -connect host:443 -www / -new \
  -time 10 -cipher $c 2>&1 | grep bytes
  echo
done
```

Такая команда позволяет измерить скорость установки SSL-соединения с помощью различных алгоритмов шифрования, что можно использовать, например, для тюнинга SSL-сервера. Если же SSL-сервера как такового еще нет, его легко эмулировать с помощью самого OpenSSL. На серверной машине запускаем OpenSSL-сервер:

```
$ openssl s_server -cert mycert.pem -www
```

На клиентской выполняем следующую команду:

```
$ openssl s_time -connect myhost:4433 \
-www / -new -ssl3
```

### Клиентская сторона

Еще одна интересная команда OpenSSL — это s_client, которая позволяет коннектиться к удаленным SSL-серверам для их тестирования. Чаще всего я использую эту команду, чтобы проверить дату выдачи сертификата. Для этого следует просто подключиться к удаленному SSL-серверу, дождаться, пока на экране появится информация о сертификате, а затем прогнать его через всё тот же openssl, чтобы вычленить даты. При использовании одной команды всё это выглядит так:

```
$ echo | openssl s_client -connect \
www.google.com:443 2>/dev/null | \
openssl x509 -dates -noout
notBefore=Oct 26 00:00:00 2011 GMT
notAfter=Sep 30 23:59:59 2013 GMT
```

![Вычленяем нужную информацию из сертификата x509](/images/Linux/Security/openssl_x509.jpg)  
_Вычленяем нужную информацию из сертификата x509_

Команду `s_client` можно также применять для тестирования сервера на уязвимость, заключающуюся в использовании нестойких алгоритмов шифрования:

```
$ openssl s_client -connect www.google.com:443 \
    -cipher LOW
CONNECTED(00000003)
140513251690152:error:14077410:SSL routines:SSL23_GET_SERVER_HELLO:sslv3 alert handshake failure:s23_clnt.c:658:
```

Сервер, не поддерживающий нестойкие алгоритмы шифрования, просто откажется устанавливать соединение, как это и произошло в случае с сервером Google. Команда `s_client` также довольно удобна для отладки различных протоколов (в этом случае она выступает в виде SSL’ного Telnet). Например:

```
$ openssl s_client -starttls smtp -crlf \
    -connect smtp.gmail.com:25
```

### Шифрование

![Шифруем файлы с помощью OpenSSL](/images/Linux/Security/openssl_encode.jpg)  
_Шифруем файлы с помощью OpenSSL_

О шифровании с помощью OpenSSL не писал только ленивый, поэтому мы остановимся не на самих принципах шифрования, а на том, как его можно использовать для вспомогательных задач. Утилита командной строки openssl удобна тем, что она, как и все остальные команды UNIX, может принимать данные на вход и имеет для них стандартный выход. В результате с помощью одной простой команды можно обеспечить, например, защищенную передачу файла по сети:

```
отправляющий$ cat /etc/passwd | openssl \
aes-256-cbc -a -e -pass pass:пароль | \
netcat -l -p 8080
принимающий$ netcat хост:8080 | openssl \
aes-256-cbc -a -d -pass pass:пароль > passwd
```

Можно также применять и различные скрипты, чтобы автоматизировать шифрование множества файлов (пароль шифрования в /tmp/passwd):

```
$ for f in * ; do [ -f $f ] && \
openssl enc -aes-256-cbc -salt -in $f \
    -out $f.enc -pass file:/tmp/passwd ; done
```

Для расшифровки отдельно взятых файлов используем следующую команду:

```
    $ openssl enc -d -aes-256-cbc -salt \
    -in файл.enc -out filename \
    -pass file:/path/to/passwd
```

Для шифрования целого каталога проще, конечно, воспользоваться такой конструкцией:

```
$ tar c каталог | openssl enc -aes-256-cbc -e \
> secret.tar.enc
```

OpenSSL удобно использовать для генерирования паролей:

```
$ openssl rand 8 -base64
O0Hqtv9l0sY=
```

А сгенерировать хеш для записи в `/etc/passwd` можно так:

```
# openssl passwd -1 my-secret-pass
$1$WA7AVhQL$y9VaGwseiKRLSGoJg21TP0
```

Кстати, кодирование в base64 может пригодиться для отправки файлов, если двоичная передача данных не поддерживается:

```
$ tar -c каталог | gzip -9 | openssl enc \
-base64 > text-message.txt
```

Возможность генерирования случайных данных можно использовать для создания фиктивных MAC-адресов:

```
$ openssl rand -hex 6 | \
sed 's/\(..\)/\1:/g; s/.$//'
f2:9e:56:fd:5a:93
```

## Выводы

Когда речь заходит о таких развитых, проверенных временем и широко применяемых инструментах, как OpenSSL и OpenSSH, юниксоиды незамедлительно начинают приводить десятки примеров их использования в повседневной жизни. Иногда эти примеры кажутся простыми и обыденными, но иногда просто поражаешься находчивости разработчиков и пользователей этих программ.

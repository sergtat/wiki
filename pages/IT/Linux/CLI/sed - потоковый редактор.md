# sed - потоковый редактор.
Команда имеет формат:

```bash
sed [ -n ] [ -e script ] [ -f sfile ] [ files ]
```

Команда копирует файлы (по умолчанию со стандартного входа) на стандартный выход, редактирует их в соответствии со своими(!) командами, размещенными в "script" (в командном файле или строке редактора [а не shell!]). По флагу "-f" берет берет файл команд из файла "sfile"; Если есть только опция "-e script", то флаг "-e" можно опустить. Флаг "-n" подавляет вывод (происходящий по умолчанию). "script" состоит из команд редактирования, по одной в строке, имеющих формат:

```bash
[ addr [ , addr ] ] cmd [ args ]
```
"sed" циклически преобразует входные строки в выходные.

Адреса "[ addr [ , addr ] ]" - это либо номера строк, либо последняя строка (символ "$"), либо регулярные выражения в стиле редактора "ed":

- "\" используется в многострочных командах для экранирования продолжения строки.
- "." совпадает с любым символом.
- Если адреса не указаны - просматриваются все входные строки.
- Если один адрес, то выбираются совпадающие строки.
- Если заданы два адреса, выбираются строки в заданном интервале.
- "!cmd" выполняется команда "cmd", для строк, которые не были выбраны по адресам. 

Для следующих (основных) функций (команд) максимальное число допустимых адресов указано в скобках.

(1)a\ text Добавляет text после указанной строки

Команда:

``` bash
who
```
Результат:

```bash
root tty1 Mar 13 17:23
mas tty2 Mar 13 18:50
sae tty6 Mar 13 17:24
sae tty5 Mar 13 17:24
```
Пример:

```
who | sed '2a\
новая строка
'
```
Результат:

```
root tty1 Mar 13 17:23
mas tty2 Mar 13 18:50
новая строка
sae tty6 Mar 13 17:24
sae tty5 Mar 13 17:24
```
(2)b label Осуществляет переход к команде ("cmd") "label:cmd". Если метка ("label") отсутствует, то переход на конец командного файла.

Пример:

```
who | sed '2a\
новая строка
b lb
2d
: lb 3d
'
```
Результат:

```
root tty1 Mar 13 17:23
mas tty2 Mar 13 18:50
новая строка
sae tty5 Mar 13 17:24
```
(2)c\ text Удаляет выбранные строки и заменяет их на "text'.

Пример:

```
who | sed '/sae/ c\
cтрока замены
'
```
Результат:

```
root tty1 Mar 13 17:23
mas tty2 Mar 13 18:50
строка замены
строка замены
```
(2)d Удаляет найденные строки

Пример:

```
who | sed '2,4d'
```
Результат:

```
root tty1 Mar 13 17:23
```

(1)i\ text Вставляет "text" на место выбранной строки. (сравните с "a\")

Пример:

```
who | sed '2i\
новая строка
'
```
Результат:

```
root tty1 Mar 13 17:23
новая строка
mas tty2 Mar 13 18:50
sae tty6 Mar 13 17:24
sae tty5 Mar 13 17:24
```
(2)p Выводит найденные строки (используется с флагом "-n").

(1)q Выходит из "sed".

(2)r rfile Читает файл "rfile" и выдает на выход.

(2)`s/reg_expr/rpl/flags` Заменяет регулярное выражение `reg_expr` на `rpl` с учетом флагов `flags`:

- g   глобально (по всей строке)
- p   выводить замены
- w wfile     сохранять заменяемое в "wfile".

Пример:

```
who | sed 's/t/T/'
echo
who | sed 's/t/T/g'
```
Результат:

```
rooT tty1 Mar 13 17:23
mas Tty2 Mar 13 18:50
sae Tty6 Mar 13 17:24
sae Tty5 Mar 13 17:24

rooT TTy1 Mar 13 17:23
mas TTy2 Mar 13 18:50
sae TTy6 Mar 13 17:24
sae TTy5 Mar 13 17:24
```
(2)y/str1/str2/ Заменяет все вхождения символов "str1" соответствующими символами "str2". Длины строк должны быть одинаковыми.

Пример:

```
who | sed 'y/sae/SAE/'

```
Результат:

```
root tty1 MAr 13 17:23
mAS tty2 MAr 13 18:50
SAE tty6 MAr 13 17:24
SAE tty5 MAr 13 17:24
```
(2)! Cmd Команда(ы) "cmd" применяются к невыбранным строкам.

Пример:

```
who | sed '2,4!d'
```
Результат:

```
mas tty2 Mar 13 18:50
sae tty6 Mar 13 17:24
sae tty5 Mar 13 17:24
```
(1)= Выдает номера строк.

Пример:

```
who | sed =

```
Результат:

```
1
root tty1 Mar 13 17:23
2
mas tty2 Mar 13 18:50
3
sae tty6 Mar 13 17:24
4
sae tty5 Mar 13 17:24
```
(2){ } Скобки группируют команды. 

#  Команда dd и все, что с ней связано
В UNIX системах есть одна очень древняя команда, которая называется dd. Она предназначена для того, чтобы что-то куда-то копировать побайтово. На первый взгляд — ничего выдающегося, но если рассмотреть все возможности этого универсального инструмента, то можно выполнять довольно сложные операции без привлечения дополнительного ПО, например: выполнять резервную копию MBR, создавать дампы данных с различных накопителей, зеркалировать носители информации, восстанавливать из резервной копии данные на носители и многое другое, а, при совмещении возможностей dd и поддержке криптографических алгоритмов ядра Linux, можно даже создавать зашифрованные файлы, содержащие в себе целую файловую систему.

Опять же, в заметке я опишу самые часто используемые примеры использования команды, которые очень облегчают работу в UNIX системах.

Начну с небольшого примера, наглядно иллюстрирующего основные параметры команды:

```bash
# dd if=/dev/urandom of=/dev/null bs=100M count=5
```
Параметры:

- `if`- указывает на источник, т.е. на то, откуда копируем. Указывается файл, который может быть как обычным файлом, так и файлом устройства.
- `of`- указывает на файл назначения. То же самое, писать можем как в обычный файл, так и напрямую в устройство.
- `bs`- количество байт, которые будут записаны за раз. Можно представлять этот аргумент как размер куска данные, которые будут записаны или прочитаны, а количество кусков регулируется уже следующим параметром.
- `count`- как раз то число, которое указывает: сколько кусочков будет скопировано.


Таким образом, описанная команда читает 5*100 мегабайт из устройства /dev/urandom в устройство /dev/null. Придавая этой команде смысловую нагрузку получается, что система сгенерирует 500 мегабайт случайных значений и запишет их в null устройство. Конечно, единственное, что сделает эта команда: нагрузит процессор на несколько секунд. Рассмотрим примеры из практики:

##  Создание образа диска:
```bash
# dd if=/dev/cdrom of=image.iso
```
Команда будет считывать из устройства данные и записывать в файл до тех пор, пока не достигнет окончания устройства. Если диск битый, можно попробовать его прочитать, игнорируя ошибки чтения:

    # dd if=/dev/cdrom of=image.iso conv=noerror

Параметр `conv` позволяет подключать несколько фильтров, применимых к потоку данных. Фильтр «noerror» как раз отключает остановку работы программы, когда наткнется на ошибку чтения. Таким образом, некоторые данные с диска все же можно будет прочитать. Точно таким образом я спас данные со своей флешки Corsair, которую погнули: подобрал подходящее положение, когда контакт есть, и сделал дамп файловой системы.

Подключить, кстати, такие образы можно при помощи команды mount с ключем `'-o loop'`:

    # mount -o loop image.iso /mnt/image

Если что-то не получается, процесс разбивается на 2 уровня:

    # losetup -e /dev/loop0 image.iso
    # mount /dev/loop0 /mnt/image

Если и так не работает, значит файловая система образа полетела.

##  Работа с носителями информации
Очень простое, хоть и не оптимальное решение клонирования жесткого диска:

    # dd if=/dev/sda of=/dev/sdb bs=4096

Все то же побайтовой копирование с размером буфера 4 Кб. Минус способа в том, что при любой заполненности разделов копироваться будут все биты, что не выгодно при копировании разделов с маленькой заполненностью. Чтобы уменьшить время копирования при манипуляции с большими объемами данных, можно просто перенести MBR на новый носитель (я ниже опишу как), перечитать таблицу разделов ядра (при помощи того же fdisk), создать файловые системы и просто скопировать файлы (не забыв сохранить права доступа к файлам).

Как вариант, можно даже по расписанию делать бекап раздела по сети. Разрулив ключи ssh будет работать такая схема:

    # dd if=/dev/DEVICE | ssh user@host «dd of=/home/user/DEVICE.img».

Когда-то читал исследование, согласно которому очень большая доля жестких дисков на барахолке подвергается восстановлению данных без привлечения чего-то специализированного, и содержит конфиденциальную информацию. Чтобы на носителе ничего нельзя было восстановить — можно забить его нулями:

    # dd if=/dev/zero of=/dev/DEVICE

Думаю, понятно на что нужно заменить DEVICE. После проведения лекций по Linux, я очень тщательно стал следить за тем, что пишу.
Проверить можно тем же dd, но преобразовав данные в hex:

    # dd if=/dev/sda | hexdump -C

Должны посыпаться нули.

##  Операции с MBR
MBR расположена в первых 512 байтах жесткого диска, и состоит из таблицы разделов, загрузчика и пары доп. байт. Иногда, ее приходится бекапить, восстанавливать и т.д. Бекап выполняется так:

    # dd if=/dev/sda of=mbr.img bs=512 count=1

Восстановить можно проще:

    # dd if=mbr.img of=/dev/sda

Причины этих махинаций с MBR могут быть разные, однако хочу рассказать одну особенность, взятую из опыта: после восстановления давней копии MBR, где один из разделов был ext3, а позже стал FAT и использовался Windows, раздел перестал видиться виндой. Причина — ID раздела, который хранится в MBR. Если UNIX монтирует файловые системы согласно суперблоку, то винды ориентируются на ID разделов из MBR. Поэтому всегда нужно проверять ID разделов при помощи fdisk, особенно если на компьютере есть винды.

##  Генерация файлов
При помощи dd можно генерировать файлы, а затем использовать их как контейнеры других файловых систем даже в зашифрованном виде. Технология следующая:

При помощи dd создается файл, забитый нулями (случайными числами забивать не рационально: долго и бессмысленно):

    # dd if=/dev/zero of=image.crypted bs=1M count=1000

Создался файл размером почти в гигабайт. Теперь нужно сделать этот файл блочным устройством и, при этом, пропустить его через механизм шифрования ядра linux. Я выберу алгоритм blowfish. Подгрузка модулей:

    # modprobe cryptoloop
    # modprobe blowfish

Ассоциация образа с блочным устройством со включенным шифрованием:

    # losetup -e blowfish /dev/loop0 image.crypted

Команда запросит ввести пароль, который и будет ключем к образу. Если ключ введен не правильно, система не смонтируется. Можно будет заново создать данные в образе, используя новый ключ, но к старым данным доступа не будет.

Создаем файловую систему и монтируем:

    # mkfs.ext2 /dev/loop0
    # mount /dev/loop0 /mnt/image

Образ готов к записи данных. После завершения работы с ним, нужно не забыть его отмонтировать и отключить от блочного loop устройства:

    # umount /dev/loop0
    # losetup -d /dev/loop0

Теперь шифрованный образ готов.

Основные идеи я расписал, однако множество задач, которые можно решить при помощи маленькой программки, имя которой состоит из двух букв, намного шире. Программа «dd» — яркий пример того, что IT'шники называют «UNIX way»: одна программа — часть механизма, выполняет исключительно свою задачу, и выполняет ее хорошо. В руках человека, который знает свое дело, которому свойственен не стандартный подход к решению задачи, такие маленькие программки помогут быстро и эффективно решать комплексные задачи, которые, на первый взгляд, должны решать крупные специализированные пакеты.

##  Другие примеры
Применив фантазию, с dd можно вообще много чего делать. Первое, что приходит на ум — дополнить файл нулями до нужной длины (нужно при создании образов разделов прошивок, например):

    dd if=/dev/zero of=new_file bs=x count=y
    dd if=old_file of=new_file bs=x count=y notrail

Т.е. создаем файл-болванку нужного размера, затем начало заменяем своими даными. Параметр notrail запрещает обрезать файл после выполнения операции.

Еще dd'ом удобно вырезать части файла:

    dd if=file.bin of=cut bs=1 skip=<оффсет> count=<размер>

… или даже патчить программки:

    printf x | dd bs=1 seek=0xdeadbabe count=1 conv=notrunc of=./someapp

\+ есть еще одно важное применение dd

    $ dd if=/dev/random count=1 > secret.key

хотя я предпочитаю

    $ head -c 512 > secret.key

ещё удобный способ гонять через сеть образы оптимальным образом:
принимающая:

    nc -l 1234 | dd of=/tmp/image.img bs=4096

отдающая:

    dd if=/dev/sda bs=4096 | nc 1.2.3.4 1234

А еще dd может отображать, сколько данных уже прочитано/записано, для этого нужно отправить процессу сигнал USR1.
когда идёт копирование большого объёма данных, бывает очень интересно «а сколько же там осталось?»

Для этого нам поможет команда

    kill -USR1 PID

где PID — ID процесса DD, в окне с dd получим текущий прогресс.

я на макбуке чтоб не городить отдельный свап-раздел для Linux делал

    dd if=/dev/zero of=/swap bs=1024 count=1048576
    mkswap /swap
    swapon /swap
    chmod 600 /swap

Не упомянута ещё одна полезная особенность — возможность создания так называемого sparse-файла. Это файл, который создаётся с заданным размером, но при этом физически не занимает пространтсво на винчестере, пока в него не будут записаны данные.

Плюс этого в том, что файл любого размера создаётся мгновенно. Пример:

    dd if=/dev/null of=bigfile bs=1M seek=1024

Эта команда мгновенно создаст файл размером в 1GiB.

